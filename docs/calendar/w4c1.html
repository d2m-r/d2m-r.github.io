<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>w4c1 – d2m-r.github.io</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-6bd9cfa162949bde0a231f530c97869d.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">d2m-r.github.io</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
        
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<!-- 

Find and replace:

- 4 : week number (numeral only)
- 1 : class number (per week, numeral only)
- Monday, January 27, 2025 : date in format Monday, January 1, 2025
- Tidying & Wrangling Data : brief title/topic of the class meeting

TODO: see if there's a way to make these variables
The problem is that if they are includes with multiple on the index page, the variables would need to process before being included. 

-->
<!--
#### Announcements/Housekeeping/Etc

Text to appear before the accordion

-->
<div id="w4c1" class="accordion">
<div class="accordion-item">
<div class="accordion-header titlebox">
<p>Week 4 | Class 1</p>
</div>
</div>
<div class="accordion-item">
<div class="datebox">
<p>Monday, January 27, 2025</p>
</div>
</div>
<div class="accordion-item">
<div class="accordion-header">
<div class="accordion-button collapsed prepbox" type="button" data-bs-toggle="collapse" data-bs-target="#prep-w4c1" aria-expanded="false" aria-controls="prep-w4c1">
<p><strong>Before class:</strong> tidyr, forcats, stringr, purrr</p>
</div>
</div>
<div id="prep-w4c1" class="accordion-collapse collapse" data-bs-parent="#w4c1">
<div class="accordion-body">
<p><strong>Readings &amp; Resources:</strong></p>
<ul>
<li>dplyr joins
<ul>
<li><a href="https://dplyr.tidyverse.org/reference/mutate-joins.html">documentation</a></li>
<li><a href="https://r4ds.hadley.nz/joins">r4ds: 19 - joins</a></li>
</ul></li>
<li>tidyr
<ul>
<li><a href="https://tidyr.tidyverse.org/">documentation</a> &amp; <a href="https://rstudio.github.io/cheatsheets/html/tidyr.html">cheatsheet</a></li>
<li><a href="https://tidyr.tidyverse.org/articles/tidy-data.html">tidyverse guide to tidy data</a></li>
<li><a href="https://r4ds.hadley.nz/data-tidy">r4ds: 5 – Data tidying</a></li>
</ul></li>
<li>forcats
<ul>
<li><a href="https://forcats.tidyverse.org/">documentation</a> &amp; <a href="https://raw.githubusercontent.com/rstudio/cheatsheets/main/factors.pdf">cheatsheet</a></li>
<li><a href="https://r4ds.hadley.nz/factors">r4ds: 16 – Factors</a></li>
</ul></li>
<li>stringr
<ul>
<li><a href="https://stringr.tidyverse.org/">documentation</a> &amp; <a href="https://github.com/rstudio/cheatsheets/blob/main/strings.pdf">cheatsheet</a></li>
<li><a href="https://r4ds.hadley.nz/strings">r4ds: 14 – Strings</a></li>
<li><a href="https://r4ds.hadley.nz/regexps">r4ds: 15 – Regular expressions</a></li>
</ul></li>
<li>purrr <em>(advanced, low priority for d2mr)</em>
<ul>
<li><a href="https://purrr.tidyverse.org/">documentation</a> &amp; <a href="https://github.com/rstudio/cheatsheets/blob/main/purrr.pdf">cheatsheet</a></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div class="accordion-item">
<div class="accordion-header">
<div class="accordion-button collapsed classbox" type="button" data-bs-toggle="collapse" data-bs-target="#class-w4c1" aria-expanded="false" aria-controls="class-w4c1">
<p><strong>Class meeting:</strong> Tidying &amp; Wrangling Data</p>
</div>
</div>
<div id="class-w4c1" class="accordion-collapse collapse" data-bs-parent="#w4c1">
<div class="accordion-body">
<p><strong>Materials:</strong></p>
<ul>
<li><a href="https://uchicago.box.com/s/awkyt76h3a2v6lcn37zxaii3k27z4fs1">Slides</a> <em>(updated 1/27/25 @12:15pm)</em></li>
</ul>
<p><strong>Class plans:</strong></p>
<ul>
<li>Lecture: Tidying &amp; wrangling data
<ul>
<li>Demo code to be run along with the lecture (combining data, tidyr, stringr, and forcats) found in the <code>demo-snippets.R</code> script</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div class="accordion-item">
<div class="accordion-header">
<div class="accordion-button collapsed infobox" type="button" data-bs-toggle="collapse" data-bs-target="#info-w4c1" aria-expanded="false" aria-controls="info-w4c1">
<p><strong>Info:</strong> Class time and Slack announcements</p>
</div>
</div>
<div id="info-w4c1" class="accordion-collapse collapse" data-bs-parent="#w4c1">
<div class="accordion-body">
<p><strong>Reminders:</strong></p>
<ul>
<li>Beginning this week, we will not spend class time addressing questions about class logistics, assignments, or other administrative topics. You will still have questions, and you will still get answers! But they will be asked and answered on Slack only.</li>
<li>I will make announcements on Slack in the dedicated <code>#announcements</code> channel. <strong>You are responsible for all the information communicated this way, even if I never bring it up in class.</strong> Be sure you have notifications turned on for Slack. At a minimum, you should get a notification when someone tags you or @everyone, when someone directly replies to a thread you’re in, and when someone posts in the <code>#announcements</code> channel.</li>
<li>There is/was an out of date version of the assessment doc in the <code>cleaning-level-1</code> mini-project. Please read the announcement in the Slack channel for more info and what to do if you have completed or intend to complete that project.</li>
</ul>
<!-- **Additional information:** -->
</div>
</div>
</div>
<div class="accordion-item">
<div class="accordion-header">
<div class="accordion-button collapsed todobox" type="button" data-bs-toggle="collapse" data-bs-target="#post-4c1" aria-expanded="false" aria-controls="after-w4c1">
<p><strong>After class:</strong> Prepare for workshop, (5!) wrangling exercises</p>
</div>
</div>
<div id="post-4c1" class="accordion-collapse collapse" data-bs-parent="#w4c1">
<div class="accordion-body">
<p><strong>To-do:</strong> Prepare for Friday’s workshop</p>
<p><strong>Note:</strong> The “conceptualize your dataset” exercise is designed to set you up for the workshop. I strongly recommend completing that exercise before Friday and spending your class time working on the to-do/to-learn list you generate, but you’re free to work on other projects if you prefer.</p>
<ol type="1">
<li>Select something to work on for the data preparation workshop on Friday. This can be a mini-project that involves cleaning and wrangling (not necessarily from the cleaning/wrangling categories) or part of the data prep needed for your final research project.</li>
<li>Create a to-do list for what you’d like to accomplish in the 80 minute workshop. Note which parts you can do on your own and which parts you’d like help with. You’ll have Dr.&nbsp;Dowling, your section TA, and your classmates to collaborate with; the more specific you can be identifying what you need help with <em>ahead of time</em> the more efficiently you’ll be able to get that help.</li>
</ol>
<p><strong>Recommended exercises:</strong> View slides and mini-project repo files for additional details for each exercise.</p>
<ul>
<li><strong>Conceptualize your dataset:</strong>
<ul>
<li>Conceptualize the dataset you’ll need to create for your final research project. Imagine what kinds of figures you’d like to create or analyses you’d like to run. What variables and observations would you need for each? Articulate your research questions and hypotheses and see how they can map onto your dataset’s structure.</li>
<li>Create a tabular <em>mockup</em> of your goal dataset(s) using Excel, pencil and paper, or any non-programmy thing you like. Don’t worry about whether you know how to get there yet. Focus on structure, not code.</li>
<li>In your final research project repo, create an .R script called <code>data-prep.R</code> (or similar). Use comments to write out in plain English the steps you’ll need to take to turn your current dataset into your goal dataset.</li>
<li>Identify parts of the comments you can fill in now with R code you already know. Create a to-learn list for parts that you’ll need to learn new functions or techniques.</li>
</ul></li>
<li><strong>Data wrangling structured exercises:</strong>
<ul>
<li><del>Walkthrough: Clean the iris Dataset</del>
<ul>
<li>Walkthrough doesn’t actually exist. At least not right now. Between the cleaning walkthrough, the cleaning projects, the in-class demos, and the highly structured format, you should be able to approach Level1 wrangling on your own. I may add one later if I see there is a need for it.</li>
</ul></li>
<li>Level 1: Recreate a starwars Dataset
<ul>
<li>Work with a medium-sized dataset (starwars) and transform to match a goal dataset. Most tasks are outlined in the assignment script.</li>
<li>Associated mini-project: <code>02_data-wrangling/01_recreate-level-1</code></li>
</ul></li>
<li>Level 2: Recreate a gapminder Dataset
<ul>
<li>Work with a more complex dataset and perform more involved wrangling and transformation tasks. General guidance is given without much structured support.</li>
<li>Associated mini-project: <code>02_data-wrangling/02_recreate-level-2</code></li>
</ul></li>
</ul></li>
<li><strong>Wrangling group make-a-mess:</strong>
<ul>
<li>Work together with a classmate to each dramatically transform/wrangle a dataset for the other(s) to recreate. Each partner will choose a publicly available dataset and transform it using tidyverse functions. You will then swap transformed datasets with your partner and attempt to recreate their work.</li>
<li>Associated mini-project: <code>02_data-wrangling/03_group-make-a-mess</code></li>
</ul></li>
<li><strong>Create a data wrangling function:</strong>
<ul>
<li>Define a function to execute procedural data wrangling tasks. Your final product should be an .R script that defines your function, then runs your function in a variety of test cases</li>
<li>“Wrangling” is loosely defined here. It should be a function that serves a useful and plausible purpose for data preparation.</li>
<li><strong>Note: You <em>may</em> use your final research project data</strong> to guide the development of your function in this mini-project, but code you submit for this mini-project will not also count toward demonstrating objectives on your final project.</li>
<li>Associated mini-project: <code>06_r-programming/03_wrangling-function</code></li>
</ul></li>
<li><strong>Recreate an existing function:</strong>
<ul>
<li>Recreate one or more existing functions from base R or a package of your choice. Your final product should be an .R script that defines your function, then compares the output with that of the original function.</li>
<li>The goal is not to literally recreate the actual function, but to define a function that <em>conceptually</em> matches the function and achieves a similar result.</li>
<li>Note: This may sound intimidating, but it really is an any-level project. You can work towards a fully equivalent function that does produces exactly the same outpu in all cases, or you can take a function and just break it down fully conceptually without writing any code at all. Or (I expect in most cases) anywhere in between.</li>
<li>Associated mini-project: <code>06_r-programming/04_recreate-function</code></li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>