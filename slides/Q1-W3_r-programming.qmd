---
title: "R Programming Language"
subtitle: "r fundamentals, packages, programming"
date: "1/20/2026" # M/D/Y
footer: "D2M-R I | Week 3" #  quarter, week, and class

format: revealjs
engine: knitr

revealjs-plugins:
  - codefocus

execute:
  echo: true
  warning: false
  message: false
editor: source
---

<!-- ## Lecture planning -->

<!-- 5.  R Language Essentials -->
<!--     1.  Introduction -->
<!--         1.  What is R and why use it? -->
<!--         2.  Object-oriented programming -->
<!--     2.  R syntax -->
<!--         1.  Variables -->
<!--         2.  Functions -->
<!--         3.  Data types -->
<!--         4.  Operators -->
<!--     3.  R data structures -->
<!--         1.  Vectors -->
<!--         2.  Lists -->
<!--         3.  Matrices -->
<!--         4.  Data frames -->
<!--         5.  Tibbles -->
<!--     4.  R packages -->
<!--         1.  What are packages? -->
<!--         2.  Installing and loading packages -->
<!--         3.  Same function, different packages, oh no! -->
<!--             1.  Functions with different names in different packages that all do the same thing -->
<!--             2.  Functions with the same name in different packages that do different things -->
<!--         4.  Commonly used packages in D2MR -->
<!-- 6.  R Programming -->
<!--     1.  Essential concepts in base R -->
<!--         1.  Object assignment -->
<!--             1.  Creating dummy variables and dataframes -->
<!--         2.  Indexing and subsetting with \[\] & \$ -->
<!--         3.  (more base R essentials) -->
<!--     2.  Iteration -->
<!--         1.  Conditional statements -->
<!--             1.  if else -->
<!--             2.  case_when -->
<!--         2.  Loops -->
<!--             1.  for loops -->
<!--             2.  while loops -->
<!--     3.  Functions in R -->
<!--         1.  Writing functions -->
<!--         2.  Function arguments and return values -->
<!--         3.  Scope and environments -->
<!--     4.  Regular expressions -->
<!--         1.  What is regex? What's the point? -->
<!--         2.  Basic syntax -->
<!--         3.  Common use cases -->

```{r}
#| label: setup
#| include: false

library(tidyverse)
```


# Welcome to R

<!-- How much I think I know about R cartoon -->

## R Programming Language

-   Built to efficiently store and manipulate data
-   Open-source, free, and flexible alternative to other statistical analysis software
-   Large, active community of users and contributors
-   Packages shared and stored on the open index CRAN (Comprehensive R Archive Network)


::: notes
R is a programming language ("environment") built to efficiently store and manipulate data, particularly matrices and arrays, based on another language called S
- Widely used among statisticians, researchers, and data miners for developing statistical software and data analysis (vs general programming languages like python)
Open-source, free, and flexible alternative to other statistical analysis software like Stata and SPSS
Has a large and active community contributing packages that facilitate a wide variety of analysis types, graphical options, and more. Many contributors store their packages on CRAN (Comprehensive R Archive Network)
:::

## R: OOP

-   R is an [object-oriented programming language (OOP)]{.keyword}
    -   [Objects]{.keyword}: contain a value and have an identifier
    -   [Classes]{.keyword}: templates for objects and their contained data type
    -   [Structures]{.keyword}: classes containing multiple objects
-   R manipulates data (objects)
    -   [Environments]{.keyword}: collections of manipulable objects
    -   [Functions]{.keyword}: procedures for creating or changing code
    -   [Arguments]{.keyword}: inputs to functions that specify procedure


::: notes
-   OBJECTS contain a value and have a name/identifier
-   CLASSES are templates for objects and the "type" of data contained within
-   STRUCTURES are classes for objects that comprise multiple objects
-   ENVIRONMENTS are collections of objects that can be manipulated
-   FUNCTIONS are procedures for creating or changing data
-   ARGUMENTS are passed to functions to specify the procedure in context

NOTE: you might hear objects and classes referred to by other terms. this is because all OOP langs have slightly different differentiation (if they have them at all!) between things like classes and "structures" for example. for our purposes the precise language isn't critical, just the concepts. but it's worth keeping in mind if you're going to go deeper into heavy programming with R or other OOPs like python
:::

## R Scripts

-   R scripts include:
    -   Series of functions (code) to carry out in order
    -   Plain text comments (non-code) that are ignored by R
-   R code is written in:
    -   R script files (.R)
    -   "Code chunks" within other file types (e.g., .Rmd & .qmd notebooks)
-   [Sourcing]{.keyword} scripts allows code in one file to "talk to" code in other files


::: notes
R scripts:
Dictate a series of functions (code) to carry out in order
Include plain text comments (non-code) that are ignored by R
R code is usually written in R script files with the .R extension
R code can also be included in "code chunks" within other file types (e.g., .Rmd & .qmd notebooks)
Some functions allow R scripts to "talk to" R code in other files
So an R project typically has multiple .R files in addition to the .Rmd

.R scripts are just that: scripts. .Rmd files are "R Notebooks", combining .R : magical files that process many kinds of code and non-code to produce a coherent, human-friendly presentation of data. 

:::

# R Syntax

## Comments

-   [Comments]{.keyword} are plain text notes within code that are ignored by R
-   Created using the `#` symbol
    -   Everything that follows *on that line* will be ignored
-   Used to:
    -   Explain code functionality
    -   Provide context or instructions
    -   Temporarily disable code during testing/debugging
    
```r
# This comment spans multiple lines. The `#` symbol must be used at the start 
# of each line. Alternatively, start the comment mid-line like below:

x <- 42  # The rest of this line is comment
# y <- x + 10  Treat this line as comment, not code
```
    
::: notes
More on comments in the introduction and best practices lecture (Week 1).
:::

## Variables

-   [Variables]{.keyword} store data values with *unique* identifiers
-   Created using the assignment operator `<-`
    -   Example: `class_name <- "D2M-R"`
-   Variable names:
    -   Are case-sensitive
        -   e.g., `Class_Name`, `class_name`, and `CLASS_NAME` are different variables
    -   MUST start with a letter or dot, not a number
        -   e.g., `student1`, `.temp_value` are valid; `1student`, `_value` are not
    -   MUST contain (only) letters, numbers, dots, or underscores
        -   e.g., `total.score`, `data_frame_1` are valid; `total-score`, `data frame` are not
    -   SHOULD be descriptive, meaningful, and pronounceable
        -   e.g., `student_age`, `is_enrolled`, `total_score`
    -   SHOULD follow consistent naming conventions
        -   e.g., `camelCase`, `snake_case`, or `dot.notation`
        -   Use a style guide like the [Tidyverse style guide](https://style.tidyverse.org/syntax.html)


::: notes

Variables are assigned values with an assignment operator. The standard assignment operator in R is `<-`, where the variable name is on the left and the value to be assigned is on the right.
Alternatively you can use `=` for assignment in the same way, but `<-` is preferred for variable assignment. `=` is used for assigning values to function arguments.
You can also use `->` to assign values in reverse, but this is very rarely used.

:::


## Main Data Types

Data you can work with in R takes one of 6[^1] forms, most commonly: 

| Data type | Description | Example |
|-----------------|----------------------------|--------------------|
| [Numeric]{.keyword .fragment fragment-index="1"} | [Decimal numbers, including whole numbers]{.fragment fragment-index="1"} | [`3.14`, `42.0`, `-1.5`]{.fragment fragment-index="1"} |
| [Integer]{.keyword .fragment fragment-index="2"} | [Whole numbers (exclusively), represented with an `L` suffix]{.fragment fragment-index="2"} | [`42L`, `-1L`, `1000L`]{.fragment fragment-index="2"} |
| [Logical]{.keyword .fragment fragment-index="3"} | [Boolean values, either `TRUE` or `FALSE`]{.fragment fragment-index="3"} | [`TRUE`, `FALSE` or `T`, `F`]{.fragment fragment-index="3"} |
| [Character]{.keyword .fragment fragment-index="4"} | [Text strings, enclosed in quotes]{.fragment fragment-index="4"} | [`"hello"`, `'123'`, `"R is great!"`]{.fragment fragment-index="4"} |

[^1]: Also [complex]{.keyword} numbers and [raw]{.keyword} vectors, rarely used in practice.

::: notes
The main data types you'll encounter in R are Numeric, Integer, Logical, and Character.
Numeric data type represents decimal numbers, including whole numbers (e.g., 3.14, 42.0, -1.5)
Integer data type represents *only* whole numbers, indicated by an L suffix (e.g., 42L, -1L, 1000L)
Logical data type represents boolean values, either TRUE or FALSE (e.g., TRUE, FALSE)
Character data type represents text strings, enclosed in quotes (e.g., "hello", '123', "R is great!")

The other 2 are [Complex]{.keyword} numbers (e.g., `1 + 2i`) and [Raw]{.keyword} vectors (used to store raw bytes of data, e.g., images or binary files). You're won't run into these in this class.
:::



## Data Types(+)

There are also a few "honorary" data types:

| Data type | Description | Example |
|------------------------|----------------------------|--------------------|
| [Factor]{.keyword .fragment fragment-index="1"} | [Leveled categorical data, stored as integers with labels]{.fragment fragment-index="1"} | [`factor(c("low", "medium", "high"))`]{.fragment fragment-index="1"} |
| [Date]{.keyword .fragment fragment-index="2"} | [Dates, stored as a special class of object]{.fragment fragment-index="2"} | [`as.Date("2025-01-31")`]{.fragment fragment-index="2"} |
| [POSIXct]{.keyword .fragment fragment-index="3"} | [Date-time objects, which include both date and time]{.fragment fragment-index="3"} | [`as.POSIXct("1776-07-04 12:01:59")`]{.fragment fragment-index="3"} |
| [empty]{.keyword .fragment fragment-index="4"} | [Not a data type, but the *absence* of data]{.fragment fragment-index="4"} | [`NA`]{.fragment fragment-index="4"} |


::: notes

Factors are used to represent categorical data with a fixed number of levels. They are stored as integers with associated labels (e.g., factor(c("low", "medium", "high")))
Dates are stored as a special class of object in R, allowing for date-specific operations (e.g., as.Date("2025-01-31"))
POSIXct represents date-time objects, which include both date and time information (e.g., as.POSIXct("1776-07-04 12:01:59"))
NA represents missing or undefined data in R. It is not a data type itself, but rather the absence of data. There are other ways to represent missing data (e.g., NULL, NaN), but NA is the most common.
-   `NA` is not the same as the numeric/integer `0` or the empty string `""`. Those are both values!!

:::

## Data Structures

R organizes data into structures to for manipulation and analysis. The main data structures are:

| Data structure | Description                  | Example                       |
|----------------|------------------------------|-------------------------------|
| [Scalar]{.keyword .fragment fragment-index="1"} | [Single data value of any data type]{.fragment fragment-index="1"} | [`42`, `"hello"`, `TRUE`]{.fragment fragment-index="1"} |
| [Vector]{.keyword .fragment fragment-index="2"} | [One-dimensional array of elements of the same data type]{.fragment fragment-index="2"} | [`c(1, 2, 3, 4, 5)`]{.fragment fragment-index="2"} |
| [List]{.keyword .fragment fragment-index="3"} | [Ordered collection of elements that can be of different data types]{.fragment fragment-index="3"} | [`list(name = "Alice", age = 30, scores = c(90, 85, 88))`]{.fragment fragment-index="3"} |
| [Matrix]{.keyword .fragment fragment-index="4"} | [Two-dimensional array of elements of the same data type]{.fragment fragment-index="4"} | [`matrix(1:6, nrow = 2, ncol = 3)`]{.fragment fragment-index="4"} |
| [Data Frame]{.keyword .fragment fragment-index="5"} | [Two-dimensional, tabular data structure with columns of potentially different data types]{.fragment fragment-index="5"} | [`data.frame(name = c("Alice", "Bob"), age = c(30, 25))`]{.fragment fragment-index="5"} |
| [Tibbles]{.keyword .fragment fragment-index="6"} | [Alternative data frames with enhanced features]{.fragment fragment-index="6"} | [`tibble::tibble(name = c("Alice", "Bob"), age = c(30, 25))`]{.fragment fragment-index="6"} |

## Data Structures: Data Frames and Tibbles

-   [Data frames]{.keyword} are 2-dimensional, tabular data structures
    -   dfs are the heart `<3` of R
    -   Special type of list
        -   Each vector in the list is a column
        -   All of equal length (e.g. same number of rows)
        -   Can be different data types *across* vectors
        -   Must be the same data type *within* a vector
-   [Tibbles]{.keyword} are alternatives to data frames
    -   Special type of data frame
    -   Used in the tidyverse ecosystem
    -   Have some enhanced features (e.g., better printing, stricter subsetting rules)
    -   Functionally equivalent to data frames (for our purposes)
    
::: notes

Data frames are the heart of R. They are lists of vectors, where each vector is a column in the data frame. All vectors must be of equal length (i.e., same number of rows), but they can be different data types across vectors (e.g., one column can be numeric, another character, etc.). Within a single vector (column), all elements must be of the same data type.

Tibbles are the tidyverse's alternative to data frames. Tibbles are *also* data frames. It's just another class applied to the same object. There are several important technical advantages to tibbles, but for our applied purposes all that you need to know is that tidyverse functions generally expect tibbles as inputs and return tibbles as outputs. So when working in the tidyverse, you'll mostly be using tibbles. Conceptually, they're going to be interchangeable with data frames.
:::


## Operators

[Operators]{.keyword} are symbols that perform operations on variables and values. The main types of operators in R are:

| Operator type | Description | Example |
|------------------------|----------------------------|--------------------|
| [Arithmetic]{.keyword .fragment fragment-index="1"} | [Perform mathematical calculations]{.fragment fragment-index="1"} | [`+`, `-`, `*`, `/`, `^`]{.fragment fragment-index="1"} |
| [Relational]{.keyword .fragment fragment-index="2"} | [Compare values and return logical results]{.fragment fragment-index="2"} | [`==`, `!=`, `<`, `>`, `<=`, `>=`]{.fragment fragment-index="2"} |
| [Logical]{.keyword .fragment fragment-index="3"} | [Combine or negate logical values]{.fragment fragment-index="3"} | [`&`, `|`, `!`]{.fragment fragment-index="3"} |
| [Assignment]{.keyword .fragment fragment-index="4"} | [Assign values to variables]{.fragment fragment-index="4"} | [`<-`, `=`, `->`]{.fragment fragment-index="4"} |

::: notes
Relational aka comparison

ASSIGNMENT: By convention, use the left arrow to assign values to variables. Use the equals sign to assign values to function arguments. Don't use the right arrow.
:::

## Operators: Arithmetic

[Arithmetic]{.keyword} do math. 

:::: row

::: col-3

::: nonincremental

-   Input: numeric data
-   Output: numeric data

:::

:::

::: col-9

::: fragment

| Operator | Description                    | Example   | Output      |
|----------|--------------------------------|-----------|-------------|
| `+`      | Addition                       | `3 + 5`   | `r 3 + 5`   |
| `-`      | Subtraction                    | `10 - 4`  |             |
| `*`      | Multiplication                 | `6 * 7`   | `r 6 * 7`   |
| `/`      | Division                       | `20 / 4`  | `r 20 / 4`  |
| `^`      | Exponentiation (power)         | `2 ^ 3`   | `r 2 ^ 3`   |
| `%%`     | Modulo (remainder of division) | `10 %% 3` | `r 10 %% 3` |

:::
:::
::::

## Operators: Relational

[Relational]{.keyword} or *comparison* operators compare objects and return a logical value (`TRUE` or `FALSE`). They are a special kind of logical operator.

:::: row

::: col-3

::: nonincremental

-   Input: numeric, character, or logical data
-   Output: logical data

:::

:::

::: col-9

::: fragment

| Operator | Description              | Example  | Output     |
|----------|--------------------------|----------|------------|
| `==`     | Equal to                 | `5 == 5` | `r 5 == 5` |
| `!=`     | Not equal to ("≠")       | `5 != 3` | `r 5 != 3` |
| `>`      | Greater than             | `7 > 4`  | `r 7 > 4`  |
| `<`      | Less than                | `3 < 8`  | `r 3 < 8`  |
| `>=`     | Greater than or equal to | `6 >= 6` | `r 6 >= 6` |
| `<=`     | Less than or equal to    | `2 <= 5` | `r 2 <= 5` |

:::

:::

::::

::: {.callout-warning .fragment .large}
### Warning: `'==' != '='`

The `==` operator checks for equality, while `=` is an (argument) assignment operator.
:::

## Operators: Logical

[Logical]{.keyword} operators combine and modify boolean values (`TRUE` or `FALSE`).

:::: row
::: col-3
::: nonincremental

-   Input: logical data
-   Output: logical data

:::
:::

::: col-9
::: fragment

| Operator | Description | Example | Output |
|----------|----------------------|-----------------|-----------------|
| `&` | "and": both sides of the operators evaluate to `TRUE` | `TRUE & FALSE` | `r TRUE & FALSE` |
| `|` | "or": at least one side of the operator evaluates to `TRUE` | `TRUE | FALSE` | `r TRUE | FALSE` |
| `!` | "not": the opposite of something's logical evaluation | `!TRUE` | `r !TRUE` |

:::
:::
::::

::: notes

It helps to think of the `!` as the word "not": `!=` is "not equal to".
`!TRUE` is `FALSE`.
`is.na(x)` means "is x missing?" (true or false), and `!is.na(x)` means "is x *not* missing?" (true or false, the opposite of `is.na(x)`).

The `&` and `|` operators come in two flavors: single or (`&` and `|`) and double (`&&` and `||`).
[Dig into this difference](https://rpubs.com/nturaga/single-v-double-logical-operators-R) if you want or need to, but for most purposes, you can just use the single operators (`&` and `|`).
:::

## Operators: Other

| Operator | Description | Example | Output |
|---------|--------------------|-------------|-------------------|
| [`<-`]{.fragment fragment-index="1"} | [*Variable* assignment operator]{.fragment fragment-index="1"} | [`x <- 5`]{.fragment fragment-index="1"} | [Assigns the value `5` to the variable `x`]{.fragment fragment-index="1"} |
| [`=`]{.fragment fragment-index="2"} | [*Argument* assignment operator]{.fragment fragment-index="2"} | [`round(3.14159, digits = 2)`]{.fragment fragment-index="2"} | [Assigns the value `2` to the `digits` argument of the `round()` function]{.fragment fragment-index="2"} |
| [`:`]{.fragment fragment-index="3"} | [Create a sequence of integers]{.fragment fragment-index="3"} | [`1:5`]{.fragment fragment-index="3"} | [`c(1, 2, 3, 4, 5)`]{.fragment fragment-index="3"} |
| [`[ ]`]{.fragment fragment-index="4"} | [ Subset elements of a vector, list, or data frame by position or name]{.fragment fragment-index="4"} | [`list(first = 1, second = 2)[2]`]{.fragment fragment-index="4"} | [`> $second > [1] 2`]{.fragment fragment-index="4"} |
| [`[[ ]]`]{.fragment fragment-index="5"} | [Extract a single element from a list by position or name]{.fragment fragment-index="5"} | [`list(first = 1, second = 2)[[2]]`]{.fragment fragment-index="5"} | [`2`]{.fragment fragment-index="5"} |
| [`$`]{.fragment fragment-index="6"} | [Extract a single element from a list or data frame by name]{.fragment fragment-index="6"} | [`list(first = 1, second = 2)$second`]{.fragment fragment-index="6"} | [`2`]{.fragment fragment-index="6"} |
| [`|>` or `%>%`]{.fragment fragment-index="7"} | [Pipe operator to pass the output of one function as the input to another]{.fragment fragment-index="7"} | [`data |> filter(condition)`]{.fragment fragment-index="7"} | [Passes `data` as the first argument to `filter()`]{.fragment fragment-index="7"} |

::: notes

The assignment operators `<-` and `=` can both be used to assign values to variables, but `<-` is preferred for variable assignment. `=` is primarily used for assigning values to function arguments or within functions.

:::

## Functions

::: {.nonincremental .grouped}

-   Basic syntax: `function_name(argument1, argument2, ...)`
    -   Example: `paste("Hello", class_name)`
-   [Functions]{.keyword}: pre-defined procedures that perform specific tasks
    -   Take 0 or more arguments as inputs
    -   Return 1 output
-   [Arguments]{.keyword}: inputs to functions that specify procedure
    -   Can be required or optional
    -   Assigned with `=` operator *or* by position following default order
        -   `round(3.14159)` is the same as `round(x = 3.14159)`
        -   `round(2, 3.14159)` is *not* the same as `round(digits = 2, x = 3.14159)`.
-   View all possible arguments in a function's documentation with `?functionname` or `??functionname`.

:::

::: notes
Functions are pre-defined procedures that perform specific tasks. They take arguments as inputs and return outputs.
Basic syntax for calling a function is the function name followed by parentheses, containing required and optional arguments: function_name(argument1, argument2, ...)
:::

## Function Definition

All functions have:

1.  Name
2.  Zero or more arguments (inputs)
3.  Procedure body (code)
4.  Return value (output)

```{r}
#| label: define-example-function
#| include: false

# Example function definition
example.function <- function(arg1, arg2) {
    # Procedure body
    # add two numeric arguments and store as `result`
    result <- arg1 + arg2
    # Return value
    # print result to console
    return(result)
}

```

::: fragment
```{r}
#| echo: true
# See the elements of a function by running the name of 
# the function without parentheses in the console

example.function

```
:::

## Defining Functions

Use the [function()]{.func} function to define your own functions:

:::: row

::: col-6

```{.r}
function_name <- function(arguments) {
    # Informative comments
    the code for your function
    return(value)
}
```

:::

::: col-6

```{r}
helloworld <- function(name, punctuation = "!") {
    # Prints greeting with name and punctuation
    greeting <- paste0("Hello ", name, punctuation)
    return(greeting)
}
```

:::

::::

:::: row

::: col-4
::: fragment
```{r}
# Specify both arguments in order 
# No argument names
helloworld("D2M-R", "!?")
```
:::
:::

::: col-4
::: fragment
```{r}
# Specify arguments out of order 
# Use argument names
helloworld(
    punctuation = "...", 
    name = "class"
)
```
:::
:::

::: col-4
::: fragment
```{r}
# Specify required argument only
# Use default for optional
helloworld("everyone")
```
:::
:::

::::


## Notes on Function Definition: Names, Arguments

::: overlap-box

::: box-title
Names
:::

::: box-content

-   Descriptive, pronounceable, consistently styled
-   Unique within your R environment

:::

:::

::: {.overlap-box .overlap-box-blue}

::: box-title
Arguments
:::

::: box-content

-   Typically limited to specific data types (e.g., numeric, character)
    -   Data constraints can be *explicitly* checked with code or *implicitly* based on function body requirements
-   Can have default values assigned, making them optional
-   Specify arguments without naming them by following documented order: `function_name(value1, value2)`
-   Specify arguments out of order by naming them: `function_name(arg2 = value2, arg1 = value1)`

:::

:::

## Notes on Function Definition: Body, Return

::: overlap-box

::: box-title
Procedure Body
:::

::: box-content
-   Can include multiple lines of code and comments
-   Scoped environment: variables created inside are not accessible outside
:::

:::

::: {.overlap-box .overlap-box-blue}

::: box-title
Return Value
:::

::: box-content

::: {.nonincremental .grouped}

-   If specified with `return()`, that value is printed to console
    -   `return(arg1 + arg2)` returns sum of `arg1` and `arg2`
-   If no `return()` is used, the last evaluated expression is returned by default
    -   `arg1 + arg2` returns sum of `arg1` and `arg2`
-   Functions have to evaluate without object assignment to return a value to the console
    -   `result <- arg1 + arg2` does not return anything

:::
:::

:::

## Reference: Useful Base R Functions (1)

| Function | Description | Example | Output |
|-----------------|----------------------|-----------------|-----------------|
| `c()` | Combine values into a vector | `c(1, 2, 3)` | `c(1, 2, 3)` |
| `paste()` | Concatenate strings together | `paste("Hello", "world!")` |  |
| `data.frame()` | Create a data frame from vectors | `data.frame(x = 1:3, y = c("a", "b", "c"))` | A data frame with 3 rows and 2 columns named `x` and `y` |
| `class()` | Check the data type of an object | `class(3.14)` | `"numeric"` |
| `str()` | Display the structure of an object | `str(mtcars)` | A summary of the `mtcars` data frame |
| `length()` | Get the length of a vector | `length(c(1, 2, 3, 4, 5))` | `5` |
| `head()` | View the first few rows of a data frame or vector | `head(mtcars)` | The first 6 (default) rows of the `mtcars` data frame |
| `summary()` | Get a summary of a data frame or vector | `summary(mtcars)` | Summary statistics for each column in the `mtcars` data frame |

## Reference: Useful Base R Functions (2)


```{r}
#| eval: true
number_list <- c(11, 37, 42, 101, 202, 1000, 2025, -3)
```

| Function | Description | Example | Output |
|-----------------|----------------------|-----------------|-----------------|
| `round()` | Round a numeric value to a specified number of decimal places | `round(67.1988, 2)` | `r round(67.1988, 2)` |
| `sum()` | Calculate the sum of a numeric vector | `sum(number_list)` | `r sum(number_list)` |
| `min()` | Find the minimum value in a numeric vector | `min(number_list)` | `r min(number_list)` |
| `max()` | Find the maximum value in a numeric vector | `max(number_list)` | `r max(number_list)` |


## Reference: Useful Base R Functions (3)


```{r}
#| eval: true
number_list <- c(11, 37, 42, 101, 202, 1000, 2025, -3)
```

| Function | Description | Example | Output |
|-----------------|----------------------|-----------------|-----------------|
| `mean()` | Calculate the mean of a numeric vector | `mean(number_list)` | `r mean(number_list)` |
| `median()` | Calculate the median of a numeric vector | `median(number_list)` | `r median(number_list)` |
| `sd()` | Calculate the standard deviation of a numeric vector | `sd(number_list)` | `r sd(number_list)` |
| `cor()` | Calculate the correlation between two numeric vectors | `cor(number_list[1:4], number_list[5:8])` | `r cor(number_list[1:4], number_list[5:8])` |



## Packages

Consider two very useful functions:

:::: row
::: col-6

```{r}
#| echo: true
# function add.two accepts numeric value `x` 
# and returns numeric x+2

add.two <- function(x) {
    return(x + 2)
    }
```

:::

::: col-6
```{r}
#| echo: true
# function add.two2 accepts any scalar value `x`, 
# coerces to x to a string, then prints the string 
# followed by the string " two"

add.two2 <- function(x) {
    return(paste(as.character(x), "two"))
    }

```
:::
::::


Someone out there really needs to add two to things in multiple ways. Tragically, base R just doesn't have the essential tools needed for all the two-adding tasks. This two-adding user would benefit from accessing both these functions together for:

-   **Reusability**: use in multiple projects without redefining
-   **Organization**: group related functions together
-   **Sharing**: bundle and share functions with others with similar needs
-   **Documentation**: add explanation for consistent use and development


::: notes

Packages are collections of many user-created functions, usually designed to work toward a specific use-case or goal.

Why combine these two functions into a package? Consider the user.
Whoever is doing this is a person who needs to add two a lot and in multiple ways. If we assume they have good reason to do so, then packaging these functions together provides several benefits:

-   Reusability: The user can easily reuse these functions across multiple projects without having to rewrite them each time.
-   Organization: Grouping related functions together in a package helps keep code organized and easier to maintain.
-   Sharing: The user can share the package with others who may also need to add two in their work.
-   Documentation: Packages often include documentation that explains how to use the functions, making it easier for others (and the user themselves) to understand and utilize the functions effectively.


:::

## Packages

::::: row

:::: col-4

-   [Packages]{.keyword} or *libraries* are collections of functions
    -   Centered on a specific use case, goal, or domain
    -   User-developed and shared
-   You need to know:
    -   Why packages are useful
    -   How to find them
    -   How to access and understand documentation
    -   How to install and load them
    -   The basics of common problem points
    
::::

:::: col-8

::: stretch-code 
```r
run_chatter_pipeline <- function(
  tbl, tbltype, target.ptcp, addressee.tags, cliptier, nearonly,
  lxonly = default.lxonly,
  allowed.gap = default.max.gap, allowed.overlap = default.max.overlap,
  min.utt.dur = default.min.utt.dur, interactants = default.interactants,
  mode = default.mode, output = default.output, n.runs = default.n.runs) {
  # step 1. read in the file
  spchtbl <- read_spchtbl(filepath = tbl, tbltype = tbltype,
                          cliptier = cliptier,
                          lxonly = lxonly, nearonly = nearonly)
  # step 2. run the speech annotations through the tt behavior detection pipeline
  ttinfotbls <- fetch_chattr_tttbl(
    spchtbl = spchtbl, target.ptcp = target.ptcp,
    cliptier = cliptier, lxonly = lxonly,
    allowed.gap = allowed.gap, allowed.overlap = allowed.overlap,
    min.utt.dur = min.utt.dur, interactants = interactants,
    addressee.tags = addressee.tags,
    mode = mode, output = output, n.runs = n.runs)
  # step 3. create a summary of the tt behavior by clip and overall, 
  # incl. the random baseline
  ttinfotbls$tt.summary <- summarize_chattr(ttinfotbls)
  return(ttinfotbls)
}
```
:::

::: contained-aside
[View the `chattr` package on GitHub.](https://github.com/marisacasillas/chattr-basic) 
:::
 
:::: 
::::: 
 


::: notes
This is the code for 1 function in the chattr package created by Marisa Casillas. Take a look at the github repo's documentation and files for a great example of how the need for a package arises & what it looks like to create that package and meet that need.

https://github.com/marisacasillas/chattr-basic

:::

## Packages: Install & Load

:::: row

::: col-6

To use functions from a package, you must first:

1.  **Install** the package on your local machine
    -   `install.packages("packagename")`
    -   Install a package **once** (on each machine)
2.  **Load** (aka **attach**) it into your R session
    -   `library(packagename)` or `require(packagename)`
    -   Load a package **each time** you start a new R session
        
:::

::: col-6

::: {.callout-note .fragment .large}

### Loading vs attaching

Calling `library()` on a package makes its functions available for use as though they were built into R itself. We usually call this *loading* the package, but technically it's *attaching* it.

Once a package is *installed* on your machine, you can *load* functions directly without attaching the whole package with `library()`. Do so by prefixing the function with the name of the package and two colors: `packagename::functionname()`.

:::
:::
::::


::: notes

Also: 
1. use library() in scripts; require() is more for using in functions
2. in addition to loading packages with each new session, good practice to also load packages at the start of each script that uses them
3. package loading order matters! loading a package with a function that has the same name as a function in an already loaded package will override the definition of that function (but you can still call the old one with `packagename::functionname()`)

`install.package("tidyverse")` – install a package on your local machine
`library(tidyverse)` – load an existing package
`require(tidyverse)` and `Require("tidyverse")` - require a package
Try those requires out and compare...
Not working? try typing ??Require into the console (note the 2 question marks) and see if you can figure out what's going on and how to fix it.
Installing/loading some packages will also install/load dependencies
e.g., library(tidyverse) will load the included readr package
readr will also load dependencies DBI, haven, readxl, and others

Having trouble? Review the troubleshooting strategies from first week!
Most packages have full documentation on CRAN
Alternatively on the package's GitHub repo or developer site
See documentation for functions within RStudio by typing ?thefunctioname into the console
:::


## Packages: Dependencies

Functions in packages are often defined using functions from other packages. The former package *depends on* the latter, its [dependency]{.keyword}.

:::: row
::: col-6

A package's CRAN documentation will list its dependencies in three categories:

1.  **Depends:** Packages that must be *installed and attached* for the package to work
2.  **Imports:** Packages that must be *installed* (but not attached) for the package to work
3.  **Suggests:** Packages that are not required for the package to work, but are recommended for full functionality

:::

::: col-6
::: {.callout-note .fragment .large}
### In practice...

When you install or load a package, R will automatically install or load its *Depends* and *Imports* dependencies for you. Usually this will just happen without you needing to even notice, but occasionally you may be prompted by the console to approve the installation/loading of dependencies. Rarely, you may need to manually install or load a dependency.

:::
:::
::::

::: notes

The same way that package functions are built using base R functions, packages also frequently (usually) build on functions from other packages. 
When a package uses functions from another package, that other package is its *dependency.*

There are two big categories of dependencies, *hard* and *soft* dependencies. 
Hard dependencies are required. 
Functions in the package simply won't work without them. 
Soft dependencies are recommended to get the most out of the package, but not strictly necessary. 
We've got three flavors of dependencies in R:

1.  **Depends:** Packages that must be *installed and attached* for the package to work
2.  **Imports:** Packages that must be *installed* (but not attached) for the package to work
3.  **Suggests:** Packages that are not required for the package to work, but are recommended for full functionality

:::

## Reference: D2M-R *Required* Packages


| Package Name       | Description                   |
|--------------------|-------------------------------|
| [`tidyverse`](https://www.tidyverse.org/)   | Ecosystem of packages for data manipulation, visualization, and analysis; includes core tidyverse packages[^2]    |
| [`bibtex`](https://cran.r-project.org/package=bibtex)      | BibTeX tools for R (bibliography management)        |
| [`citr`](https://github.com/crsh/citr)          | RStudio add-in to insert citations                  |
| [`DescTools`](https://cran.r-project.org/package=DescTools) | Tools for descriptive statistics                      |
| [`gt`](https://gt.rstudio.com/)                | Easily create presentation-ready tables               |
| [`knitr`](https://yihui.org/knitr/)              | Dynamic report generation in R                        |
| [`lme4`](https://cran.r-project.org/package=lme4)        | Linear and generalized linear mixed-effects models    |
| [`psych`](https://cran.r-project.org/package=psych)       | Procedures for psychological, psychometric, and personality research |
| [`quarto`](https://quarto.org/)                | Tools for working with the Quarto markdown publishing system      |
| [`rmarkdown`](https://rmarkdown.rstudio.com/)       | Authoring dynamic documents with R Markdown           |
| [`usethis`](https://usethis.r-lib.org/)         | Automate package and project setup tasks              |

[^2]: Core tidyverse packages include: `ggplot2`, `dplyr`, `tidyr`, `readr`, `purrr`, `tibble`, `stringr`, `lubridate`, and `forcats`.


## Reference: D2M-R *Suggested* Packages


| Package Name       | Description                   |
|--------------------|-------------------------------|
| [`broom`](https://broom.tidymodels.org/)             | Convert statistical analysis objects into tidy tibbles            | 
| [`data.table`](https://rdatatable.io/)        | Fast data manipulation and aggregation                            |
| [`flextable`](https://davidgohel.github.io/flextable/)  | Functions for reporting tabular results in R Markdown and Word    |
| [`haven`](https://haven.tidyverse.org/)             | Import and export of SPSS, Stata, and SAS files                   |
| [`janitor`](https://sfirke.github.io/janitor/)           | Simple tools for examining and cleaning dirty data                |
| [`kableExtra`](https://haozhu233.github.io/kableExtra/)        | Construct complex tables in R Markdown                            |
| [`papaja`](https://crsh.github.io/papaja/)            | APA style manuscript preparation with R Markdown                  |
| [`pwr`](https://cran.r-project.org/package=pwr)               | Power analysis for general linear models                          |
| [`RColorBrewer`](https://cran.r-project.org/package=RColorBrewer)      | Color palettes for maps and figures                               |
| [`patchwork`](https://patchwork.data-imaginist.com/)                 | Combine separate ggplot2 plots into the same graphic   |
| [`vcd`](https://cran.r-project.org/package=vcd)               | Visualizing categorical data                                      |
| [`ggsci`](https://nanx.me/ggsci/)               | Scientific journal and sci-fi movie color palettes for ggplot2 |



# R Programming

## Indexing & Subsetting

**Indexing** and **subsetting** are ways to select specific elements from data structures like vectors, lists, data frames, and matrices.

[Indexing]{.keyword}: Identifying the position of an element within a data structure (or position*s* within sub-structures) using numeric position or name.

[Subsetting]{.keyword}: Extracting a portion of a data structure based on specific criteria (e.g., selecting certain rows or columns from a data frame), including indexing.

## Reference: Indexing & Subsetting

Create a vector of integers beginning with one number and ending with another using `:`:

```{r}
#| output-location: fragment
 
3:7
```

```{r}
#| output-location: fragment
 
1:5 == c(1, 2, 3, 4, 5)
```

## Reference: Indexing & Subsetting

Select elements of a vector by position or name with `[ ]`:

```{r}
#| output-location: fragment

my_vector <- c(1, 10, 3, fourth = 1000, fifth = 2)
my_vector[3] # select 4th element of a vector, return the named or unnamed element
```

```{r}
#| output-location: fragment

my_vector["fourth"] # select element named 'fourth' from a vector, return the named element
```

## Reference: Indexing & Subsetting

Select elements of a list by position or name with `[ ]` and `[[ ]]`:

```{r}
#| output-location: fragment

my_list <- list(first = 1, second = 2)
my_list[2] # select 2nd element of a list, returned as a list
```
```{r}
#| output-location: fragment

my_list[[2]] # select 2nd element of a list, returned as the element itself
```

```{r}
#| output-location: fragment


my_list[["second"]] # select element named 'second' from a list, returned as the element itself
```

## Reference: Indexing & Subsetting

Select elements of a data frame or matrix by position or name with `[ ]` and `[[ ]]`, using `,` to separate row and column indices:

```{r}
#| output-location: fragment

mtcars[1, ]  # first row
```

```{r}
#| output-location: fragment

mtcars[, 1]  # first column
```

```{r}
#| output-location: fragment

mtcars[1, "mpg"] # value in the first row and first column (named "mpg")
```

## Reference: Indexing & Subsetting

Select a list or data frame element by name with `$`:

```{r}
#| output-location: fragment

my_list <- list(first = 1, second = 2)
my_list$second # returns `2`
```

```{r}
#| output-location: fragment

mtcars$mpg # 'mpg' column of mtcars 
```

## Environments

[Environments]{.keyword}: data structures that store variable bindings (associations between variable names and their values) in R.

-   **Global environment**: the main workspace where user-defined variables and functions are stored during an R session. Default view in the Environment pane.
-   **Local environments**: created when functions are called; variables defined within a function are stored in its local environment and are not accessible outside the function unless explicitly returned.

::: {.callout-caution .large .fragment}

### Scope

Environments are *scoped*, meaning that variables defined within an environment are only accessible within that environment and its child environments. 

*Global* environment variables are accessible from its local environment children, but *local* environment variables are not accessible from the parent global environment.

:::

## Control Flow 

[Control flow]{.keyword}: the order in which individual statements, instructions, or function calls are executed or evaluated within a program. 

In R, control flow is managed using [conditional statements]{.keyword} and [loops]{.keyword}.

![](../images/comics-memes/monster-parade-loop.png){alt="Illustrated for loop example. Input vector is a parade of monsters, including monsters that are circles, triangles, and squares. The for loop they enter has an if-else statement: if the monster is a triangle, it gets sunglasses. Otherwise, it gets a hat. The output is the parade of monsters where the same input parade of monsters shows up, now wearing either sunglasses (if triangular) or a hat (if any other shape)."}

## Conditional Statements

[Conditional statements]{.keyword} allow you to execute different blocks of code based on whether certain conditions are met.

:::: row

::: col-6

| Statement | Description |
|------------------------|----------------------------|
| `if` | Execute a block of code if a specified condition is `TRUE` |
| `if...else` | Execute one block of code if a condition is `TRUE`,
| `if...else if...else` | Execute different blocks of code based on multiple conditions |

:::

::: col-6

```{r}
#| output-location: fragment

# if statement

x <- 3

if (x > 0) {
    print("x is positive")
}

# if...else statement
y <- 10

if (y > 5) {
    print("y is greater than 5")
} else {
    print("y is not greater than 5")
}
```

:::

::::

## Conditional Statements: Example


```{r class="stretch-code"}
#| output-location: fragment

# Example of if...else if...else statement

z <- 0 # change this value to test different outcomes

# Check if z is a number
# if it is, do the checks inside the {}
# if it isn't, go to the else statement
if (is.numeric(z)) {
    if (z > 0) {      # is it positive?
        print("z is positive")  # if it is, say so and then STOP
    # if not, is it negative?
    } else if (z < 0) {     # if not, is it negative?
        # if it is, say so and then STOP
        print("z is negative")  # if it is, say so and then STOP
    # if not positive and not negative, it must be zero
    } else {
        print("z is zero") # say so and then STOP
    }
# if it isn't a number, say so and then STOP
} else {
    print("z is not a number")
}

```

## Conditional Functions

**R's conditional functions** provide a way to perform conditional operations in a more functional, condensed style.

:::: {.row .gap-3}

::: {.col-3 .fragment}

| Function | Package | Description |
|------------------------|----------------------------|
| `ifelse()` | base | returns values based on a condition |
| `if_else()` | dplyr | Same, with stricter data type consistency |
| `case_when()` | dplyr | allows for multiple conditions and corresponding values |

:::

::: {.col-8 .fragment}

The examples from the previous slide can be written more concisely:

::: fragment

```{r class="stretch-code"}
#| output-location: fragment

y <- 10

ifelse(y > 5, "y is greater than 5", "y is not greater than 5")

```

:::

::: fragment

```{r class="stretch-code"}
#| output-location: fragment

z <- 0 # change this value to test different outcomes

print(case_when(
    !is.numeric(z) ~ "z is not a number",
    z > 0 ~ "z is positive",
    z < 0 ~ "z is negative",
    TRUE ~ "z is zero"
))
```

:::
:::
::::

::: notes

What's the difference between `ifelse()` and `if_else()`?

- The `ifelse()` function is a base R function that is vectorized, meaning it can handle vectors of conditions and return corresponding values for each element. It is generally faster for large datasets but can be less strict about data types.
- The `if_else()` function is part of the `dplyr` package in the tidyverse. It is also vectorized but is stricter about data types, ensuring that the output type matches the input type. This can help prevent unexpected results when working with different data types.

:::

## Iteration

[Iteration]{.keyword}, or looping, allows you to repeat a block of code multiple times, either a fixed number of times or while a certain condition is met.

| Loop Type | Description |
|----------|----------------------------|
| `for` | Repeats a block of code for each item in a sequence or vector |
| `while` | Repeats a block of code as long as a specified condition is `TRUE` |

## Loops Conceptually

::: {.d-flex .nonincremental style="gap: 1em;"}
::: {.contained-box style="flex: 1;" .fragment}
::: {.box-icon}

![](../images/icons/do-next.png)

:::
::: {.box-title}
{{< bi 1-circle >}}  When I say go
:::
:::

::: {.contained-box style="flex: 1;" .fragment}
::: {.box-icon}

![](../images/icons/creativity.png)
:::
::: {.box-title}
{{< bi 2-circle >}}  Do this thing
:::
:::

::: {.contained-box style="flex: 1;" .fragment}
::: {.box-icon}

![](../images/icons/consistency.png)
:::
::: {.box-title}
{{< bi 3-circle >}}  And keep doing it
:::
:::

::: {.contained-box style="flex: 1;" .fragment}
::: {.box-icon}

![](../images/icons/priority.png)
:::
::: {.box-title}
{{< bi 4-circle >}}  Until I say stop
:::
:::
:::



## `for` Loops

::: {.d-flex .nonincremental style="gap: 1em;"}
::: {.contained-box style="flex: 1;"}
::: {.box-title}
{{< bi 1-circle >}}  When I say go 
:::

::: {.box-content .fragment}
`i = my_list[1]`
:::
:::

::: {.contained-box style="flex: 1;"}
::: {.box-title}
{{< bi 2-circle >}}  Do this thing 
:::
::: {.box-content .fragment}
`print(i)`
:::
:::

::: {.contained-box style="flex: 1;"}
::: {.box-title}
{{< bi 3-circle >}}  And keep doing it 
:::
::: {.box-content .fragment}
`i = my_list[2]` <br> `i = my_list[3]...`
:::
:::

::: {.contained-box style="flex: 1;"}
::: {.box-title}
{{< bi 4-circle >}}  Until I say stop 
:::
::: {.box-content .fragment}
`my_list[6] > length(my_list)`
:::
:::
:::

```{r style="margin-top: 1em;"}
#| output-location: column

# Create a finite sequence of numbers
my_list <- c(1, 3, 5, 7, 9)

# for each value i in the sequence num_list
for (i in my_list) {
    # print the value of i to the console
    print(i)
# iterate to the next value in the sequence 
    # until there are no values left
}
```

## `while` Loops

::: {.d-flex .nonincremental style="gap: 1em;"}
::: {.contained-box style="flex: 1;"}
::: {.box-title}
{{< bi 1-circle >}}  When I say go 
:::

::: {.box-content .fragment}
`i = 1`
:::
:::

::: {.contained-box style="flex: 1;"}
::: {.box-title}
{{< bi 2-circle >}}  Do this thing 
:::
::: {.box-content .fragment}
`print(i)` <br>
`i <- i + 1`
:::
:::

::: {.contained-box style="flex: 1;"}
::: {.box-title}
{{< bi 3-circle >}}  And keep doing it 
:::
::: {.box-content .fragment}
`print(i + 1)` <br>
`print(i + 2)...`
:::
:::

::: {.contained-box style="flex: 1;"}
::: {.box-title}
{{< bi 4-circle >}}  Until I say stop 
:::
::: {.box-content .fragment}
`i >= 6`
:::
:::
:::

```{r style="margin-top: 1em;"}
#| output-location: column

# Initialize counter variable i to 1
i <- 1 

# while (if) i=1, then i=2...til i=6
while (i < 6) {
    # print the value of i to the console
    print(i)
    i <- i + 1 # Increment i by 1
# check whether "while" condition still holds
    # repeat if TRUE
    # stop if FALSE
}
```

## `for` vs `while`

:::: row
::: col-7

::: {.card style="margin: 1em;"}

::: card-header
::: card-title
`for`
:::
:::

::: {.card-body .tightlist}

-   Known, finite sequence
-   Repeats for each item in sequence
-   Does not require an explicit counter variable
-   Iteration happens automatically

:::

:::

::: {.card .card-alt1 style="margin: 1em;"}

::: card-header
::: card-title
`while`
:::
:::

::: {.card-body .tightlist}

-   Unknown, potentially infinite sequence
-   Repeats while condition is `TRUE`
-   Requires an explicit counter variable
-   Iteration controlled by defined condition

:::

:::

:::

::: col-5

::: {.alert .alert-danger .nonincremental .fragment}

<h3 style="text-align: center;">
![](../images/icons/priority.png){style="height: 1em"}
**Warning: Infinite loops**
![](../images/icons/priority.png){style="height: 1em"}
</h3>

Use `while` for potentially **but not actually infinite** sequences.
Your code must eventually lead to a `FALSE` evaluation:

1. Define the iteration mechanism:
    -   `i <- i+1`
2. Ensure the `while` condition will eventually be `FALSE` when iterated using that mechanism 
    -   `i < 6`

:::

:::

::::

::: notes

-   Use a `for` loop when you know in advance how many times you want to iterate (i.e., finite sequence).
-   Use a `while` loop when you want to continue iterating until a certain condition is met, and you may not know in advance how many iterations that will take (i.e., potentially infinite sequence).
    -   But not *actually* infinite! Always ensure that the condition will eventually become `FALSE` to avoid infinite loops.

:::



## Regular Expressions

![](../images/comics-memes/xkcd-regex.png){alt="xkcd comic strip about regular expressions. Two people are lamenting having to find text formatted as an email address. A third character swoops in on a rope saying 'Everybody stand back. I know regular expressions.', types something, and swoops away."}

## What are Regular Expressions?

[Regular expressions (regex or regexp)]{.keyword}: sequences of characters that form a search pattern, primarily used for string matching and manipulation.

::: fragment
Examples of regex syntax:

::: nonincremental
-   `^Hello`: matches any string that starts with "Hello"
-   `[aeiou]`: matches any single vowel character (a, e, i, o, u)
-   `\d{3}-\d{2}-\d{4}`: matches a pattern like a US Social Security number (e.g., "123-45-6789")
    -   or with R's escaping: `\\d{3}-\\d{2}-\\d{4}`

:::
:::
    
::: {.callout-tip .fragment .large}

Use tools like [regex101](https://regex101.com/) or [RegExr](https://regexr.com/) to test and visualize regex patterns interactively. Just be careful about escaping rules when using R! (More info below.)

:::

::: notes
Regular expressions (regex or regexp) are sequences of characters that form a search pattern. They are primarily used for string matching and manipulation, allowing you to search, match, and manipulate text based on specific patterns.
:::

## Basic Regex Syntax: Essentials

| Symbol | Description | Example |
|--------|----------------------|----------------------|
| `.` | Matches any single character except newline | `a.b` matches "acb", "a1b", "a b" |
| `^` | Matches the start of a string | `^Hello` matches "Hello world" |
| `$` | Matches the end of a string | `world$` matches "Hello world" |
| `*` | Matches 0 or more occurrences of the preceding element | `ab*` matches "a", "ab", "abb", "abbb" |
| `+` | Matches 1 or more occurrences of the preceding element | `ab+` matches "ab", "abb", "abbb" but not "a" |
| `?` | Matches 0 or 1 occurrence of the preceding element | `ab?` matches "a" and "ab" |
| `[]` | Matches any one character within the brackets | `[aeiou]` matches "a", "e", "i", "o", or "u" |
| `|` | Logical OR operator | `cat|dog` matches "cat" or "dog" |
| `()` | Groups expressions | `(ab)+` matches "ab", "abab", "ababab" |

::: notes

What about a logical AND operator? 
There isn't one! The whole regex pattern is treated as a sequence of elements that must *all* be matched in order. "and" is built-in.

:::


## Basic Regex Syntax: Other Useful Matches

| Symbol | Description | Example |
|--------|----------------------|----------------------|
| `\d` | Matches any digit (0-9) | `\d` matches "0", "1", ..., "9" |
| `\w` | Matches any word character (alphanumeric + underscore) | `\w` matches "a", "b", ..., "z", "A", "B", ..., "Z", "0", "1", ..., "9", "_" |
| `\s` | Matches any whitespace character (space, tab, newline) | `\s` matches " ", "\t", "\n" |
| `{n}` | Matches exactly n occurrences of the preceding element | `a{3}` matches "aaa" |
| `{n,}` | Matches n or more occurrences of the preceding element | `a{2,}` matches "aa", "aaa", "aaaa", ... |
| `{n,m}` | Matches between n and m occurrences of the preceding element | `a{2,4}` matches "aa", "aaa", or "aaaa" |

## Escaping

Characters that have assigned functions will perform that function unless they are escaped.

[Escape]{.keyword} a special character to refer to its literal meaning.

-   **R** uses a backslash (`\`) as the escape character.
-   **Regex** *also* uses a backslash (`\`) as the escape character.
-   When using regex in R, you need to use double backslashes (`\\`) to escape special characters because the backslash itself is an escape character in R strings.

::: {.alert .alert-warning .nonincremental .fragment}

TELL ME WHY.

:::

::: notes

Why? Imagine R is humming along, reading your string. It sees a backslash. Aha! A special character is coming up! So R uses the backslash to escape the special character, and the special character is interpreted literally.
But wait! The special character is supposed to be part of a regex pattern, and regex also uses backslashes to escape special characters. Whatever follows the backslash is going to be interpreted literally. When the string is passed to the regex engine, it sees a backslash followed by a special character. It does not see the backslash as part of the regex pattern, because R has already used it to escape the special character,

So now, to get the regex engine to see the backslash as part of the regex pattern, you need to escape the backslash itself in R. Hence, you use double backslashes (`\\`) in R strings to represent a single backslash in the regex pattern. The first backslash escapes the second backslash in R, and the regex engine sees a single backslash followed by the special character, allowing it to interpret the special character according to regex rules.

:::

## Using Regex in R (with `base`)

Base R uses "grep" functions for regex operations.

-   grep = **g**lobal **r**egular **e**xpression **p**rint.
-   Semi-consistent argument order: `function_name(pattern_to_find, string_to_search, other_args)`

::: {.overlap-box .fragment}

::: box-title
Common grep functions:
:::

::: {.box-content .nonincremental}

-   `grep()`: Search for patterns in strings and return indices of matches
-   `grepl()`: Search for patterns and return logical vector indicating matches
-   `gsub()`: Replace occurrences of a pattern with a specified replacement

::: 

:::


## Using Regex in R (with `base`): Examples

```{r}
# Example strings
text <- "The rain in Spain stays mainly in the plain."
title <- "My Fair Lady"
```



```{r class="fragment"}
#| output-location: column
# Find which list elements contain "ain"
grep("ain", c(title, text))
```

```{r class="fragment"}
#| output-location: column
# Replace "ain" with "XXX"
gsub("ain", "XXX", text)
```

```{r class="fragment"}
#| output-location: column
# Check if the string starts with "The"
grepl("^The", text)
```

## Using Regex in R (with `stringr`)

The [stringr]{.pkg} package (part of the tidyverse) provides an alternative set of string manipulation functions, using consistent syntax and behavior across nearly all `stringr` functions

-   Naming: `str_` + descriptive function name
-   Argument order: `str_func(string_to_search, pattern_to_find, other_args)`
    -   *Note:* this flips the order of the first two arguments compared to base R's grep functions
-   Accepts regex patterns plus some user-friendlier, tidyvers-ier enhancements

::: {.overlap-box .overlap-box-blue .fragment}

::: box-title
Common stringr functions:
:::

::: {.box-content .nonincremental}

-   `str_which()`: Search for patterns in strings and return indices of matches
-   `str_detect()`: Search for patterns and return logical vector indicating matches
-   `str_replace_all()`: Replace occurrences of a pattern with a specified replacement

::: 

:::

::: aside
[stringr cheat sheet](https://rstudio.github.io/cheatsheets/html/strings.html)
:::

::: notes

stringr has a good reason to flip the order. When using pipes (`%>%`), the data being operated on is passed as the first argument to the function. More when we talk tidyverse

:::

## Using Regex in R (with `stringr`): Examples

```{r}
# Load stringr package for string manipulation
library(stringr)

# Example strings
text <- "The rain in Spain stays mainly in the plain."
title <- "My Fair Lady"
```

```{r class="fragment"}
#| output-location: column
# Find which list elements contain "ain"
str_which(c(title, text), "ain")
```

```{r class="fragment"}
#| output-location: column
# Replace "ain" with "XXX"
str_replace_all(text, "ain", "XXX")
```

```{r class="fragment"}
#| output-location: column
# Check if the string starts with "The"
str_detect(text, "^The")
```

# Summary

## R Language

-   R is an **object-oriented programming language** for statistical computing and graphics
-   R syntax includes:
    -   **Variables**: store data values
    -   **Data Types**: numeric, character, logical, etc.
    -   **Data Structures**: vectors, lists, data frames, matrices
    -   **Functions**: reusable blocks of code that perform specific tasks
    -   **Comments**: annotate code with `#`, ignored by R
-   Case-sensitive but whitespace insensitive
-   Functions are called using parentheses, with arguments passed inside
-   Install and load packages to extend R's functionality with additional functions and tools


## R Programming

-   **Indexing** and **Subsetting**: selecting specific elements from data structures using position or name
-   **Environments**: data structures that store *scoped* variable bindings, including global and local environments
-   **Control Flow**: managing the order of code execution using
    -   Conditional statements (`if`, `if...else`)
    -   Conditional functions (`ifelse()`, `case_when()`)
    -   `for` loops: iterate over a known, finite sequence
    -   `while` loops: iterate while a condition is `TRUE`
-   **Regular Expressions (regex)**: sequences of characters forming search patterns for string matching and manipulation
    -   Basic syntax includes symbols like `.`, `^`, `$`, `*`, `+`, `?`, `[]`, `|`, `()`
    -   Escaping special characters with backslashes (`\`), using double backslashes (`\\`) in R strings
    -   Use regex in R with base `grep`-style functions or stringr `str_`-style functions
