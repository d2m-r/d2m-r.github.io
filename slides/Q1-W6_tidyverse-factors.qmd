---
title: "Tidyverse Wrangling with Factors"
subtitle: "factors, levels, categorical data w/ base & `forcats`"
date: "2/10/2026"
footer: "D2M-R I | Week 6 & 7" #  quarter, week, and class

format: revealjs
engine: knitr

revealjs-plugins:
  - codefocus
  - fullscreen

fullscreen: false

execute:
  echo: true
  warning: false
  message: false
editor: source
---

```{r}
#| label: setup
#| include: false

library(tidyverse)
set.seed(123)
```

# Introduction to Factors

## Categorical Data

::: overlap-box

::: box-title

Categorical variables

:::

::: box-content

-   Represent a set of distinct groups or categories that are:
-   Finite in number
-   Mutually exclusive
-   Non-numeric
    -   i.e., mathematical operations don't make sense

:::

:::

::: {.overlap-box .accent1}

::: box-title

Examples

:::

::: box-content

-   Gender
-   Education level
-   Survey responses (e.g., "Agree", "Neutral", "Disagree")

:::

:::



## Categorical Data Types

::: overlap-box

::: box-title

Category Types

:::

::: box-content

-   **Nominal**: No inherent order (e.g., colors, types of fruit)
-   **Ordinal**: Meaningful order (e.g., "Low", "Medium", "High")

:::

:::

::: {.overlap-box .accent1}

::: box-title

Also known as

:::

::: box-content

-   Factor variables
-   Discrete variables
-   Qualitative data 
    -   Terrible. Don't call it that.

:::

:::





::: notes

Do not call categorical data "qualitative data." It's a terrible name that misrepresents what categorical data is. Categorical data is still data, and it can be analyzed quantitatively (e.g., counts, proportions, regression models). The term "qualitative" implies that it's not data or not quantitatively analyzable, which is incorrect and misleading.

It also discredits the value of actual qualitative data (like interview transcripts, open-ended survey responses, etc.) by lumping it together with categorical data, which is a completely different type of data that requires different methods of analysis.

:::


## Factor data

-   [Factors]{.keyword} are R's representation of categorical data
-   Integer vectors with level labels

::: fragment

```{r}
#| label: factor-structure

f <- factor(c("low", "medium", "high", "medium", "low"))

typeof(f)
str(f)
```

:::

## Factors vs. strings

::::: container-fluid

:::: row

::: col-6

::: overlap-box

::: box-title

Factors

:::

::: box-content

- Stored as integers with labels
- Memory efficient (at large scale)
- Control ordering
- Useful for: 
    -   non-numeric modeling
    -   visualization

:::
        
:::

:::

::: col-6

::: {.overlap-box .accent1}

::: box-title

Strings

:::

::: box-content

- Stored as many ordered character units
- More memory (at large scale)
- Flexible manipulation
- Useful for: 
    -   text processing
    -   unique values

:::
        
:::

:::

::::

:::::

## Memory efficiency

Compare object size of factor vs character vector with repeated values

:::: row

::: {.col-4 .fragment}

```{r}
#| label: factor-vs-string-small-define

# Small scale 
small_strings <- c(
    "low", "medium", 
    "high", "medium", "low")
small_factor <- factor(small_strings)

```

```{r}
#| label: factor-vs-string-small-compare

# Strings: ~.3 KB
object.size(small_strings) 

# Factor: ~.7 KB - negligibly larger
object.size(small_factor) 
```


:::

::: {.col-4 .fragment}

```{r}
#| label: factor-vs-string-large-define

# Larger scale
big_strings <- rep(c(
    "low", "medium", "high"), 
    length.out = 10000) # repeat to length 10,000
big_factors <- factor(big_strings)

```

```{r}
#| label: factor-vs-string-larger-compare

# Strings: ~80.2 KB
object.size(big_strings)  

# Factor:  ~40.6 KB - ~50% smaller
object.size(big_factors)  
```

:::

::: {.col-4 .fragment}

```{r}
#| label: factor-vs-string-long-strings-define

# Long strings
long_strings <- rep(c(
    "Dissatisfied, very dissatisfied, or extremely dissatisfied", 
    "Not at all dissatisfied, somewhat dissatisfied, or a little dissatisfied", 
    "Neutral and/or no response given"), 
    length.out = 2000) # repeat to length 2,000
long_factors <- factor(long_strings)
```


```{r}
#| label: factor-vs-string-long-strings-compare

# Strings: ~8.4 KB
object.size(long_strings) 

# Factor: ~4.8 KB - ~50% smaller
object.size(long_factors)  
```

:::

::::


::: notes
Break point for memory efficiency is somewhere around 200ish strings (depending on length, number of unique levels, etc.). For small datasets where strings are more or equally efficient, it's not going to matter enough to care about the size distinction. For enormous datasets where you do need to care about efficiency, that's where factors do impact processing notably.
::: 


## Base R factor functions

:::: row

::: col-6

**Core base R factor functions:**

- `factor()`: Create factor
- `levels()`: View/set levels
- `nlevels()`: Count levels
- `as.character()`: Convert to string
- `as.numeric()`: Get underlying integers

:::

::: {.col-6 .fragment}

```{r}
#| label: base-r-factors

f <- factor(c("low", "medium", "high", "medium", "low"))

levels(f)  # View levels
nlevels(f) # Count levels
as.character(f)  # Convert to strings
as.numeric(f)  # Get underlying integers
```

:::

::::

::: notes
Integers are assigned in alphabetical order by default (high=1, low=2, medium=3), not order of appearance.
::: 

## `forcats` package: simplify working with factors {.left-sidebar-slide fullscreen=true style="font-size: .8;"}

![](../images/icons/tv-icons/forcats.png){.absolute top=".5em" left="1em" height="3em; z-index: 10;"}

::: sidebar-column

::: sidebar-title

[forcats]{.pkg}: <br> Simplify working with factors

:::

::: sidebar-content

-   Tidyverse package _**for cat**_egorical variables
-   Largely helpers/wrapper for base R functions with:
    -   Consistent `fct_*` naming
    -   More intuitive syntax
    -   Better compatibility with tidyverse workflows
    -   Additional functionality for common tasks

:::

:::

::: main-content

::: {.r-stretch style="display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: minmax(0, 1fr) minmax(0, 1fr); gap: 0.8em;"}

::: {.contained-box .fragment style="display: flex; flex-direction: column; align-items: center; padding: 0.4em 0.3em 0.2em 0.3em;"}

::: {.box-icon style="margin-bottom: 0.1em;"}

{{< bi boxes >}}

:::

::: {.box-title style="font-size: 0.9em; margin-bottom: 0.2em;"}

::: {style="margin-bottom: -.4em !important; margin-top: -.4em !important;"}

Create

:::

:::

::: {.box-content style="text-align: center;"}

Create factors

:::

:::

::: {.contained-box .fragment style="display: flex; flex-direction: column; align-items: center; padding: 0.4em 0.3em 0.2em 0.3em;"}

::: {.box-icon style="margin-bottom: 0.1em;"}

{{< bi search >}}

:::

::: {.box-title style="font-size: 0.9em; margin-bottom: 0.2em;"}

::: {style="margin-bottom: -.4em !important; margin-top: -.4em !important;"}

Inspect

:::

:::

::: {.box-content style="text-align: center;"}

Examine levels

:::

:::

::: {.contained-box .fragment style="display: flex; flex-direction: column; align-items: center; padding: 0.4em 0.3em 0.2em 0.3em;"}

::: {.box-icon style="margin-bottom: 0.1em;"}

{{< bi intersect >}}

:::

::: {.box-title style="font-size: 0.9em; margin-bottom: 0.2em;"}

::: {style="margin-bottom: -.4em !important; margin-top: -.4em !important;"}

Combine

:::

:::

::: {.box-content style="text-align: center;"}

Combine and standardize levels

:::

:::

::: {.contained-box .fragment style="display: flex; flex-direction: column; align-items: center; padding: 0.4em 0.3em 0.2em 0.3em;"}

::: {.box-icon style="margin-bottom: 0.1em;"}

{{< bi sort-down >}}

:::

::: {.box-title style="font-size: 0.9em; margin-bottom: 0.2em;"}

::: {style="margin-bottom: -.4em !important; margin-top: -.4em !important;"}

Reorder

:::

:::

::: {.box-content style="text-align: center;"}

Change level order

:::

:::

::: {.contained-box .fragment style="display: flex; flex-direction: column; align-items: center; padding: 0.4em 0.3em 0.2em 0.3em;"}

::: {.box-icon style="margin-bottom: 0.1em;"}

{{< bi recycle>}}

:::

::: {.box-title style="font-size: 0.9em; margin-bottom: 0.2em;"}

::: {style="margin-bottom: -.4em !important; margin-top: -.4em !important;"}

Reassign

:::

:::

::: {.box-content style="text-align: center; overflow: hidden; min-height: 0; font-size: 0.9em; line-height: .9;"}

Rename and redistribute levels

:::

:::

::: {.contained-box .fragment style="display: flex; flex-direction: column; align-items: center; padding: 0.4em 0.3em 0.2em 0.3em;"}

::: {.box-icon style="margin-bottom: 0.1em;"}

{{< bi plus-slash-minus>}}

:::

::: {.box-title style="font-size: 0.9em; margin-bottom: 0.2em;"}

::: {style="margin-bottom: -.4em !important; margin-top: -.4em !important;"}

Add/Drop

:::

:::

::: {.box-content style="text-align: center;"}

Add or remove levels

:::

:::

:::

:::



::: notes

Create: `as_factor`
Inspect: `fct_unique`, `fct_count`, `fct_match`
Combine: `fct_c`, `fct_unify`
Reorder: `fct_relevel`, `fct_infreq`, `fct_reorder`, `fct_reorder2`, `fct_rev`, `fct_inorder`, `fct_shift`, `fct_shuffle`
Reassign: `fct_recode`, `fct_relabel`, `fct_anon`, `fct_collapse`, `fct_lump_*n`, `fct_other`
Add/Drop: `fct_expand`, `fct_drop`, `fct_na_value_to_level`

:::



# Create Factors

## Create factors

:::: row

::: col-6

::: fragment

-   **Base:** Create factors with `factor()`
    -   Alphabetizes levels by default
    -   Includes arguments to specify order, labels, and more

:::

::: fragment

```{r}
#| label: create-factors-factor

# Using factor()
f1 <- factor(c("low", "medium", "high", "medium", "low"))
levels(f1)  # Alphabetical order
as.numeric(f1)  # high=1, low=2, medium=3
```

:::

:::

::: col-6

::: fragment

-   **`forcats`:** Create factors with `as_factor()`
    -   Preserves order of appearance
    -   No additional specification needed or possible
<br><br>

:::

::: fragment

```{r}
#| label: create-factors-as-factor

# Using as_factor() from forcats
f2 <- as_factor(c("low", "medium", "high", "medium", "low"))
levels(f2)  # Order of appearance
as.numeric(f2)  # low=1, medium=2, high=3
```
:::

:::

::::

## Create: specify level order

:::: row

::: col-6

-   Define levels when creating factors: `f <- factor(x, levels = c(...))`
    -   `levels` argument: Set specific levels and order
    -   Overrides default (alphabetical)
    -   Elements of `levels` vector must match unique values in `x`
    -   Levels not in `x` will be created but have no observations
    -   Observations in `x` without corresponding levels will become NA
-   *no forcats function*
    -   `as_factor()` necessarily preserves order of appearance

:::

::: {.col-6 .fragment}

```{r}
#| label: specify-levels-factor

x <- c("B", "A", "C", "A", "B")
f <- factor(x, levels = c("C", "B", "A"))
f
levels(f)  # Custom order
```

:::

::::

## Create: specify level labels

`factor(x, levels = c(...), labels = c(...))`

```{r}
#| label: specify-labels-define

x <- c("B", "A", "C", "A", "B")
```


:::: row

::: {.col-6 .fragment}

```{r}
#| label: specify-levels-only

f_levels_only <- factor(x, 
    levels = c("C", "B", "A"))

f_levels_only # Custom order, default labels
levels(f_levels_only)  

```

:::

::: {.col-6 .fragment}

```{r}
#| label: specify-with-labels

f_with_labels <- factor(x, 
    levels = c("C", "B", "A"), 
    labels = c("Gamma", "Beta", "Alpha"))
f_with_labels # Custom order & labels

```

:::

::::

::: notes

In other languages (like Stata), factors can have both levels and labels, where levels are the underlying values and labels are the human-readable names. In R, the `levels` of a factor serve both purposes: they define the unique categories (levels) and also provide the labels that are displayed when you print the factor. When you use the `labels` argument in `factor()`, it essentially renames the levels to the specified labels. So in R, levels and labels are intertwined, and you control both with the `levels` and `labels` arguments when creating a factor.

:::


## Create: specify meaningful order


**For ordinal data with meaningful order**

- Likert scales (Strongly Disagree → Strongly Agree)
- Education levels (HS → Bachelor's → Master's → PhD)
- Sizes (Small → Medium → Large)


::: bubble-chain

  <p class="bubble-left fragment">Didn't we just define and redefine order?</p>
  <p class="bubble-right fragment">Kind of.  Regular factors have levels with no inherent order (nominal data), where the "order" is simply how R stores and displays them. Ordered factors explicitly encode an order among the levels (ordinal data).</p>
  
:::

## Create: ordered vs. unordered factors

:::: row

::: {.col-6 .fragment}

`factor(..., ordered = TRUE)`: 

Encode order with argument

```{r}
#| label: ordered-factors-argument

sizes_unordered <- factor(
    c("medium", "small", "large", "small", "medium"),
    levels = c("small", "medium", "large"),
    ordered = TRUE)
sizes_unordered
levels(sizes_unordered)
as.numeric(sizes_unordered) 
```

:::

::: {.col-6 .fragment}

`ordered(...)`: 

Create ordered factor directly

```{r}
#| label: ordered-factors-direct

sizes_ordered <- ordered(
    c("medium", "small", "large", "small", "medium"),
    levels = c("small", "medium", "large"))
sizes_ordered
levels(sizes_ordered)
as.numeric(sizes_ordered) 

```

:::

::::

::: notes

Levels always have an order, because they are stored as integers and integers are necessarily ordered.
*Ordered* factors explicitly encode that order for ordinal data. This allows for meaningful comparisons and appropriate statistical treatment in models.

When you actually view the contents of an ordered factor, you'll see that its levels aren't just listed in order, they have `<` between them. 
This is saying to the human user (and R functions that respect ordered factors) that there is a meaningful order to these levels, not simply an arbitrary assignment to numerals that happen to have an order because that's how numbers work.

::: 


## Meaningful ordering

:::: row

::: {.col-6 .fragment}

```{r}
#| label: unordered-factor-order

sizes_unordered <- factor(
    c("medium", "small", "large", "small", "medium"),
    levels = c("small", "medium", "large"),
    ordered = FALSE)

sizes_unordered

```

```{r}
#| label: unordered-factor-comparisons
#| warning: false

sizes_unordered[1] < sizes_unordered[3]  
sizes_unordered[2] > sizes_unordered[4]  
sizes_unordered[2] == sizes_unordered[4] 
```

:::

::: {.col-6 .fragment}

```{r}
#| label: ordered-factor-order

sizes_ordered <- factor(
    c("medium", "small", "large", "small", "medium"),
    levels = c("small", "medium", "large"),
    ordered = TRUE) # or use ordered() function

sizes_ordered


```


```{r}
#| label: ordered-factor-comparisons
#| warning: false

sizes_ordered[1] < sizes_ordered[3]  
sizes_ordered[2] > sizes_ordered[4]  
sizes_ordered[2] == sizes_ordered[4] 
```

:::

::::


## Inspect factors

:::: row

::: col-5

**Examine existing factor structure**

:::

::: col-7

```{r}
#| label: create-factor-inspect
x <- factor(c("medium", "high", "low", "high", "high", "medium"))
```

:::

::::


:::: row

::: col-6

::: fragment

- Base:
    - `levels()`: View level labels
    - `nlevels()`: Count levels

:::

::: fragment

```{r}
#| label: inspect-levels-base

levels(x) # character vector
nlevels(x) # integer count
```

:::

:::

::: col-6

::: fragment

- `forcats`:
    - `fct_unique()`: Unique values of levels
    - `fct_count()`: Frequency table  

:::

::: fragment
    
```{r}
#| label: inspect-levels-forcats
fct_unique(x) # factor of levels
fct_count(x) # tibble of lvl & ct.
```

:::

:::
::::

::: notes

Aside from `factor` and `levels`, it's `forcats` only from here on out!

:::

## Combine factors

::::: {.container-fluid style="margin-top: -3em;"}

:::: row

::: col-8

:::

::: col-4

```{r}
#| label: combine-factors-define

f1 <- factor(c("a", "c"))
f2 <- factor(c("b", "a"))
```

:::

::::

:::: row

::: {.col-6 .fragment}

`fct_c()`: Combine factors

```{r}
#| label: combine-factors-fct-c

f_combined <- fct_c(f1, f2)

f1
f2
f_combined

```

:::

::: {.col-6 .fragment}

`fct_unify()`: Unify levels of factors

```{r}
#| label: combine-factors-fct-unify

unified_list <- list(f1, f2)
f_unified <- fct_unify(unified_list)

f_unified

```

:::
::::

:::::

# Reorder Factor Levels

## Reorder: manual assignment (relevel)

`fct_relevel()`: Move levels to specific positions

```{r}
#| label: manual-reordering-create
#| output-location: column

f <- factor(c("medium", "low", "high", "medium", "low"))
f # Current order
```


:::: row

::: {.col-6 .fragment}

Move specific level to front

```{r}
#| label: manual-reordering-move-front

# Move "low" to front
fct_relevel(f, "low")  
```


Move one level relative to another

```{r}
#| label: manual-reordering-relative-position

# Move "medium" before "high"
fct_relevel(f, "medium", "high")  
```

:::

::: {.col-6 .fragment}

Move one level to specific position

```{r}
#| label: manual-reordering-absolute-position

# Move "high" after first level
fct_relevel(f, "high", after = 1)  

# Move "low" to last position
fct_relevel(f, "low", after = Inf)
```

:::

::::

::: notes
-   Note: Conceptually this is reordering levels, but there is a different function called `fct_reorder()` (coming up) that does reorders levels with a different mechanism. In most cases when you need to manually reorder levels, you're going to use `relevel()`.

after = 0: Move "medium" to first position (same as fct_relevel(f, "medium")) with fct_relevel(f, "medium", after = 0) 
:::


## Reorder: reverse

`fct_rev()`: Reverse current level order

::: fragment

```{r}
#| label: reverse-order-create

f <- factor(c("large", "small", "medium", "medium", 
    "small", "medium", "small", "medium", "medium", "medium"), 
    levels = c("small", "medium", "large"))
f
```

:::

::: fragment

```{r}
#| label: reverse-order-rev
fct_rev(f)
```

:::

## `fct_rev` use case: flip bar chart

**Use case**: Flip bar chart from top-to-bottom to bottom-to-top

:::: row

::: {.col-6 .fragment}

```{r}
ggplot(data.frame(f), aes(x = f)) + 
  geom_bar() +
  labs(title = "Bar Chart with Original Factor Order")
```

:::

::: {.col-6 .fragment}

```{r}
ggplot(data.frame(f), aes(x = fct_rev(f))) +
  geom_bar() +
  labs(title = "Bar Chart with Reversed Factor Order")
```

:::

::::

## Reorder: by appearance

`fct_inorder()`: Order by first appearance

```{r}
#| label: reorder-by-appearance-create
#| output-location: column

f <- factor(c("b", "b", "a", "c", "c", "c"))
f
```

:::: row

::: {.col-6 .fragment}

Reorder by first appearance

```{r}
#| label: reorder-by-appearance-inorder

fct_inorder(f)
```

:::

::: {.col-6 .fragment}

Equivalent to creating with `as_factor()`

```{r}
f <- as_factor(c("b", "b", "a", "c", "c", "c"))
f
```

:::

::::

## Reorder: by frequency

`fct_infreq()`: Reorder from most to least common

```{r}
#| label: reorder-by-frequency-create
f <- factor(c("b", "b", "a", "c", "c", "c"))
f
```

::: fragment

Reorder by frequency, most common first

```{r}
fct_infreq(f)
```

:::

## `fct_infreq` use case: interpretable bar charts

```{r}
#| label: bar-chart-factor-create

f <- factor(c("b", "b", "b", "a", "c", "c"))
```

:::: row

::: {.col-6 .fragment}

```{r}
#| label: bar-chart-default-ordered

ggplot(data.frame(f), aes(x = f)) +
    geom_bar() +
    labs(title =
        "Bar Chart with Default (Alphabetical) Ordered Factor") +
    theme(text = element_text(size = 20))
```

:::

::: {.col-6 .fragment}

```{r}
#| label: bar-chart-infreq-ordered

ggplot(data.frame(f), aes(x = fct_infreq(f))) +
    geom_bar() +
    labs(title =
        "Bar Chart with Frequency-Ordered Factor") +
    theme(text = element_text(size = 20))
```

:::

::::

::: notes

Probably the most common use case for `fct_infreq()` is to create bar charts with bars ordered by frequency (most common first). This is often more informative than the default alphabetical ordering.

:::

## Reorder: by another variable (summary)

```{r}
#| label: create-small-diamonds
#| include: false

diamonds_100 <- diamonds |> 
    filter(carat < 1.2) |> 
    slice_sample(n = 100)
```


`fct_reorder(f, x, fun)`: Order factor by summary of another variable 

:::: row

::: {.col-6 .fragment}

Default: sort by level median

```{r}
#| label: reorder-by-other-variable-median

ggplot(diamonds_100, aes(
    x = fct_reorder(cut, carat), y = carat)) +
    geom_boxplot() +
    labs(title = "Reordered by Median Carat Value") +
    theme(text = element_text(size = 20))
```


:::

::: {.col-6 .fragment}

Or sort by any other summary function, e.g., `max`

```{r}
#| label: reorder-by-other-variable-max

ggplot(diamonds_100, aes(
    x = fct_reorder(cut, carat, max), y = carat)) +
    geom_boxplot() +
    labs(title = "Reordered by Maximum Carat Value") +
    theme(text = element_text(size = 20))
```

:::

::::

## Reorder: by another variable (relationship)

`fct_reorder2(f, x, y)`: Order by relationship with two variables (great for line plots)

:::: row

::: {.col-6 .fragment}

Line plot without reorder

```{r}
#| label: reorder-by-other-variable-default

diamonds_100 |> 
    ggplot(aes(x = carat, y = price, 
        color = cut)) +
    geom_line(stat = "summary", fun = mean) +
    labs(title = "Line Plot with Legend Ordered by Endpoint") +
    theme(text = element_text(size = 20))
```

:::

::: {.col-6 .fragment}

Compare last values of y for each level of f across x 

```{r}
#| label: reorder-by-other-variable-reorder2

diamonds_100 |> 
    ggplot(aes(x = carat, y = price, 
        color = fct_reorder2(cut, carat, price))) +
    geom_line(stat = "summary", fun = mean) +
    labs(title = "Line Plot with Legend Ordered by Endpoint") +
    theme(text = element_text(size = 20))
```

:::

::::

::: notes
Notice that if you use a forcats variable like fct_reorder on a non-factor variable, it will convert it to a factor with the new order. This is a common way to reorder factors on the fly for plotting without needing to create a new variable in your dataset.
::: 


# Reassign Factor Levels

## Reassign: rename levels

`fct_recode()`: Manually rename specific levels `new_name = "old_name"`

::: fragment

Create factor with messy level names

```{r}
#| label: rename-levels-create

f <- factor(c("Low ", "Medium", "High", "Medium ", "Low", "high", "Hihg"))
f
```

:::

::: fragment

Clean up names. Map multiple old levels to same new or existing level individually.

```{r}
f_clean <- fct_recode(f,
                      Low = "Low ",
                      Medium = "Medium ",
                      High = "high",
                      High = "Hihg")

f_clean
```


:::

::: notes

You can create new codes and they don't have to be strings
:::

## Reassign: collapse levels manually

`fct_collapse()`: Combine multiple levels into one `new_name = c("old1", "old2")`

```{r}
#| label: collapse-levels-create

f <- factor(c("A", "A", "B", "B", "B", "C", "C", "C", "C", "D", "E", "F", "G", "G", "G", "G", "G"))

```


::: fragment

```{r}
#| label: collapse-levels-manual
#| output-location: column

f_collapsed <- fct_collapse(
    f,
    Group1 = c("A", "B"),
    Group2 = c("C", "D"),
    Group3 = "E")

f_collapsed
```

:::

## Reassign: lump levels manually

`fct_other()`: Lump (non/)specified levels into "Other"

```{r}
#| label: lump-levels-create

f <- factor(c("A", "A", "B", "B", "B", "C", "C", "C", "C", "D", "E", "F", "G", "G", "G", "G", "G"))
```

:::: row

::: {.col-6 .fragment}

```{r}
#| label: lump-levels-manual-keep

fct_other(f, keep = c("A", "B", "C"))
```

:::

::: {.col-6 .fragment}

```{r}
#| label: lump-levels-manual-drop

fct_other(f, drop = c("A", "B", "C"))
```

:::

::::

::: notes

"Lumping" is not the same as "dropping" despite the argument being "drop." It creates an "other" level, remaps levels to "other", then drops unused levels.

:::

## Reassign: lump levels automatically

`fct_lump_*()` family: Keep levels by condition, lump rest into "Other"

```{r}
#| label: collapse-levels-create-dup

f <- factor(c("A", "A", "B", "B", "B", "C", "C", "C", "C", "D", "E", "F", "G", "G", "G", "G", "G"))

```

:::: row

::: {.col-4 .fragment}

`fct_lump_n()`: keep most frequent N

```{r}
#| label: collapse-levels-lump-n

fct_lump_n(f, n = 3)
```

:::

::: {.col-4 .fragment}

`fct_lump_prop()`: keep levels above percent frequency

```{r}
#| label: collapse-levels-lump-prop

fct_lump_prop(f, prop = 0.2)
```

:::

::: {.col-4 .fragment}

`fct_lump_min()`: keep levels with at least N observations

```{r}
#| label: collapse-levels-lump-min

fct_lump_min(f, min = 4)
```

:::

::::

::: notes
**Collapsing levels**: Use `fct_collapse()` to combine multiple levels into single level. Show `fct_lump()` to automatically lump least common levels into "Other". Demonstrate `fct_lump_n()`, `fct_lump_prop()`, `fct_lump_min()` for different lumping strategies.
::: 

# Add/Drop Levels

## Add/Drop: add and remove levels


:::: row

::: {.col-4 .fragment}

`fct_expand()`: Add new levels without observations

```{r}
#| label: add-levels-create

f_abc <- factor(c("A", "B", "C"))
f_abc
```

```{r}
#| label: add-levels-expand

fct_expand(f, "D", "E")
```

:::

::: {.col-4 .fragment}

`fct_drop()`: Remove levels with no observations

```{r}
#| label: drop-levels-create

f_abcde <- factor(c("A", "B", "C"), 
    levels = c("A", "B", "C", "D", "E"))
f_abcde

```

```{r}
#| label: drop-levels-drop

fct_drop(f_abcde)
```


:::

::: {.col-4 .fragment}

In combination

```{r}
#| label: remove-again

# add unused levels
fct_expand(f_abc, "D", "E") |> 
    # then drop them
    fct_drop()

```

:::

::::


## `fct_drop` use case: tibble filter


::: fragment

```{r}
#| label: drop-create-tibble
#| output-location: column

# Create a tibble with a factor variable
t <- tibble(
    f = factor(c("A", "B", "C", "D", "E")),
    i = c(1:5)
)

t
```
:::

::: fragment


```{r}
#| label: drop-view-factor-column
#| output-location: column

t$f
```

:::

::: fragment

```{r}
#| label: drop-unused-levels-filter
#| output-location: column


t_subset <- filter(t, i <= 3)
t_subset$f

```

:::

::: fragment

```{r}
#| label: drop-unused-levels-droplevels
#| output-location: column

fct_drop(t_subset$f)
```

:::

::: notes
**Dropping unused levels**: Compare `droplevels()` with `fct_drop()` to remove levels with no observations. Commonly used after filtering data.
:::



## Add/Drop: handle missing values

`fct_na_value_to_level()`: Convert between `NA` values and `NA` levels

```{r}
#| label: handle-missing-values-create

f <- factor(c("A", "B", NA, "A", "C", NA, "B"))
f
```

:::: row

::: {.col-6 .fragment}

Create explicit NA level

```{r}
#| label: handle-missing-values-na-level

fct_na_value_to_level(f)
```

:::

::: {.col-6 .fragment}

Convert NAs to named level

```{r}
#| label: handle-missing-values-named-level

fct_na_value_to_level(f, level = "(Missing)")
```

:::

::::

::: notes
WHY?
- Make missingness visible in plots
- Include NAs in counts and summaries

`fct_explicit_na()` is deprecated, but you'll still see it and it still works. The new name `fct_na_value_to_level()` is more descriptive of what the function actually does, which is to convert NA to explicit "(Something)" level.


::: 


## See Also 

`forcats` functions we didn't talk about:

::: {.nonincremental}
1.  Create: n/a -- just `as_factor()`
2.  Inspect:
    1.  `fct_match(f, lvls)`: check for levels in f 
3.  Combine:
    1.  `fct_cross(f1, f2)`: Create interaction factor
4.  Reorder
    1.  `fct_inseq()`: Order by natural sequence
    2.  `fct_shift()`: Shift levels L or R, wrapping around
    3.  `fct_shuffle()`: Randomly permute levels
5.  Modify
    1.  `fct_lump_lowfreq()`: Lump low-frequency levels
    2.  `fct_relabel()`: Rename levels with function
    3.  `fct_anon()`: Anonymize to random integers

:::


# Practical Applications

## Data cleaning workflow

**String cleaning → Factor creation**

:::: row

::: col-5

Common workflow:

1. Trim whitespace
2. Standardize case
3. Fix inconsistencies
4. Convert to factor

:::

::: col-7

::: fragment

Messy categorical (string) data with inconsistent entries

```{r}
#| label: messy-categorical-data

# Create messy data
messy <- c(" Low", "medium ", "HIGH", "medium", " low", "high", NA, "Hihg")
```

:::

::: fragment

Pipeline wth `str` and factor creation in one step

```{r}
#| label: cleaning-pipeline

messy |> 
    str_trim() |> 
    str_to_lower() |> 
    str_replace("hihg", "high") |> 
    factor(levels = c("low", "medium", "high"), 
        ordered = TRUE) |> 
    fct_na_value_to_level("no response")
```

:::

:::

::::

::: notes
**Data cleaning workflows**: Demonstrate pipeline combining string cleaning (trimming, case conversion) with factor creation. Show fixing inconsistent categorical entries.
::: 

## Visualization preparation

**Make better plots with factor control**

- Reorder for sorted bars (`fct_infreq`, `fct_reorder`)
- Collapse rare categories (`fct_lump_*`)
- Control legend order

## Visualization preparation

:::: row

::: col-5

Create a simple bar chart

```{r}
#| label: bar-chart-unsorted
#| echo: true
#| eval: false

diamonds_100 |> 
    ggplot(aes(x = clarity)) +
    geom_bar() +
    labs(title = "Bar chart with no ordering",
        x = "Default factor variable")
```

:::

::: col-7

::: fragment

```{r}
#| label: bar-chart-unsorted-view
#| echo: false

diamonds_100 |> 
ggplot(aes(x = clarity)) +
geom_bar() +
labs(title = "Bar chart with no ordering",
    x = "Default factor variable") +
# increase ALL text size
theme(text = element_text(size = 20))
```
:::

:::

::::


## Visualization preparation

:::: row

::: col-5

Reorder factor by decreasing frequency

```{r}
#| label: bar-chart-freq
#| echo: true
#| eval: false

diamonds_100 |> 
ggplot(aes(x = 
        fct_infreq(clarity))) +
geom_bar() +
labs(title = "Bar chart with freq. ordering",
    x = "Somewhat arranged factor variable")
```

:::

::: col-7

::: fragment


```{r}
#| label: bar-chart-freq-view
#| echo: false

diamonds_100 |> 
    ggplot(aes(x = 
            fct_infreq(clarity))) +
    geom_bar() +
    labs(title = "Bar chart with freq. ordering",
        x = "Somewhat arranged factor variable") +
    # increase ALL text size
    theme(text = element_text(size = 20))
```

:::

:::

::::

## Visualization preparation 

:::: row

::: col-5

Lump rare categories for cleaner visualization

```{r}
#| label: bar-chart-freq-lump
#| echo: true
#| eval: false

diamonds_100 |> 
ggplot(aes(x = 
        fct_lump_n(clarity, n = 4) |> 
        fct_infreq())) +
geom_bar() +
labs(title = "Bar chart with freq. 
    ordering + lumping",
    x = "Cleverly arranged factor variable")
```
:::

::: col-7

::: fragment


```{r}
#| label: bar-chart-freq-lump-view
#| echo: false

diamonds_100 |> 
    ggplot(aes(x = 
            fct_lump_n(clarity, n = 4) |> 
            fct_infreq())) +
    geom_bar() +
    labs(title = "Bar chart with freq. ordering + lumping",
        x = "Cleverly arranged factor variable") +
    # increase ALL text size
    theme(text = element_text(size = 20))
```

:::

:::

::::

## Visualization preparation 

:::: row

::: col-5

Move "other" level to the end

```{r}
#| label: bar-chart-freq-lump-other-end
#| echo: true
#| eval: false

diamonds_100 |> 
ggplot(aes(x = 
        fct_lump_n(clarity, n = 4) |> 
        fct_infreq() |> 
        fct_relevel("Other", 
            after = Inf))) +
geom_bar() +
labs(title = "Bar chart with freq. 
    ordering + lumping + relevel",
    x = "Brilliantly arranged factor variable")
```

:::

::: col-7

::: fragment

```{r}
#| label: bar-chart-freq-lump-other-end-view
#| echo: false

diamonds_100 |> 
    ggplot(aes(x = 
            fct_lump_n(clarity, n = 4) |> 
            fct_infreq() |> 
            fct_relevel("Other", after = Inf))) +
    geom_bar() +
labs(title = "Bar chart with freq. ordering + lumping + relevel",
    x = "Brilliantly arranged factor variable") +
    # increase ALL text size
    theme(text = element_text(size = 20))
```

:::

:::

::::

::: notes
**Preparing data for visualization**: Show reordering factors for sorted bar charts and line plots. Demonstrate collapsing rare categories for cleaner plots. Illustrate controlling legend order.
::: 

## Modeling categorical data

**Factor order matters in models!** The first level is the reference category. *Example:* using `mtcars` data, predict `mpg` using `cyl` (number of cylinders) as a factor variable.

:::: row

::: {.col-6 .fragment}

Fit regression model with `cyl` as factor

```{r}
#| label: model-reference-level-default

summary(
    lm(mpg ~ factor(cyl), data = mtcars)
)
```

:::

::: {.col-6 .fragment}

Use `fct_rev()` to change reference level

```{r}
#| label: model-reference-level-reverse

summary(
    lm(mpg ~ fct_rev(factor(cyl)), data = mtcars)
)

```
:::

::::

::: notes
The first level is the "dummy" or reference category. Output is only interpretable in relation to that first level.
:::