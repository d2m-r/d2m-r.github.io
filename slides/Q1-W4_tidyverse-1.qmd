---
title: "Data Wrangling in the Tidyverse"
subtitle: "ecosystem, read-in/-out, data manipulation"
date: "1/27/2026" # M/D/Y
footer: "D2M-R I | Week 4" #  quarter, week, and class

format: revealjs
engine: knitr

revealjs-plugins:
  - codefocus
  - fullscreen

fullscreen: false

execute:
  echo: true
  warning: false
  message: false
editor: source
---

```{r}
#| label: setup
#| include: false

library(tidyverse)
```

# Tidy Data

## What Makes Data "Tidy"? 

::: {.r-stack}

![](../images/tidyverse/tidy-data-def-frag1.jpg){.fragment height=700}

![](../images/tidyverse/tidy-data-def-frag2.jpg){.fragment height=700}

![](../images/tidyverse/tidy-data-def-frag3.jpg){.fragment height=700}

![](../images/tidyverse/tidy-data-def-frag4.jpg){.fragment height=700}

![](../images/tidyverse/tidy-data-def-frag5-FULL.jpg){.fragment height=700}
:::

<aside>Illustrations from the [Openscapes](https://www.openscapes.org/) blog [Tidy Data for reproducibility, efficiency, and collaboration](https://www.openscapes.org/blog/2020/10/12/tidy-data/) by Julia Lowndes and Allison Horst</aside>


---

![](../images/tidyverse/tolstoy.png){.absolute top="0" right="0" height="200"}

![](../images/tidyverse/tidy-data-quote-frag1.jpg){.fragment height="300"}


![](../images/tidyverse/tidy-data-quote-frag2.jpg){.fragment height="300"}

---

::: columns

::: {.column}

![](../images/tidyverse/tidy-data-workshop-frag1.jpg){.fragment height="800"}

:::
::: {.column}

![](../images/tidyverse/tidy-data-workshop-frag2.jpg){.fragment height="800"}
:::

:::

## Messy vs. Tidy: Example {data-background-image="../images/misc/mms.jpg" data-background-opacity=0.1}

::::: {.container-fluid style="margin-top: -150px;"}
:::: {.row style="margin-bottom: 50px;"}
::: col-6

:::
::: col-6
::: {.callout-important style="font-size: 1.2em;"}

## These tables hold exactly the same data!

What are the differences? What are the advantages of each?

:::
:::
::::




```{r}
#| message: false
#| warning: false
#| eval: true
#| echo: false
library(messy)
library(tidyverse)

# Generate a messy dataset
set.seed(123)

mm.raw <- read_tsv("../data/MM.tsv") |> 
    # Assign an ID number to each row in a column "Bag"
    mutate(Bag = row_number()) |> 
    relocate(last_col(), .before = 1)

mm.messy <- mm.raw |> 
    set_names("ID", "RED", "GREEN", "Blue", "Orannge", "Ylw.", "X", "WT.GRAM") |> 
    relocate(last_col(), .before = 4) |>
    relocate(X, .after = 2) |>
    add_whitespace(messiness = .9) |>
    duplicate_rows(.3) |>
    make_missing()

mm.tidy <- mm.raw |> 
    pivot_longer(
        cols = 2:7,
        names_to = "Color",
        values_to = "Number"
    ) |> 
    select(Bag, Color, Number, Bag_Weight = Weight)
    
```

:::: row

::: col-7

```{r}
#| echo: true
#| eval: true

mm.raw
```

:::
::: col-5

```{r}
#| echo: true
#| eval: true
mm.tidy
```
:::
::::
:::::

::: bubble-chain
  <p class="bubble-left fragment">That messy data looks pretty clean to me...</p>
  <p class="bubble-right fragment">It *is* clean! It's just not **tidy**.</p>
:::

# Terminology Detour

## Messy, Clean, Tidy

::::: container-fluid

:::: row

::: col-6

::: {.card .fragment .h-100 style="font-size: .8em"}

::: card-header
::: {.card-title style="color: #fff"}

Messy data:

:::
:::

::: {.card-body .lessgap}

```{r}
#| echo: true
#| eval: true
mm.raw
```

:::
:::

:::

::: col-6

::: {.card .card-alt1 .fragment .h-100 style="font-size: .8em"}

::: card-header
::: {.card-title style="color: #fff"}

Also messy data:

:::
:::

::: {.card-body .lessgap}

```{r}
#| echo: true
#| eval: true
mm.messy
```

:::
:::

:::

::::

:::::

::: notes

**messy ≠ bad** (except in the tidyverse context)

- Data wrangling starts with reading your data, then prepping it for visualization & analysis
- To use tidyverse packages, this prepping includes tidying messy data
- This can be shockingly complicated and time-consuming!

:::


## "Messy" is messy

**Messy** can either mean "not clean" or "not tidy"

- **Always bad:** unclean + untidy (= messy)
- **Sometimes good:** clean + untidy (= messy)
- **Usually good:** clean + tidy (= tidy)

::: bubble-chain
  <p class="bubble-left fragment">It would make more sense to call it "untidy."</p>
  <p class="bubble-right fragment">You are not wrong.</p>
:::

## Tidy Data: Iris

```{r}
#| include: false

iris_1 <- iris |> head(10)

iris_2 <- iris |> 
    pivot_longer(
        cols = c(Sepal.Length, Sepal.Width, Petal.Length, Petal.Width),
        names_to = c("Flower_Part", "Measurement_Type"),
        names_sep = "\\."
    ) |>
    head(10)
```

::::: container-fluid

:::: row

::: col-4

The `iris` dataset is a classic example of tidy data.

Which of these two versions of `iris` is tidy?

:::

::: {.col-8 style="margin-top: -4.5em; padding-bottom: 1em;"}

::: {.overlap-box .smaller}

::: box-title
In tidy data:
:::

::: box-content
::: nonincremental

<ol>
<li>Each variable is one column.</li>
<li>Each observation is one row.</li>
<li>Each measurement is one cell.</li>
<li class="fragment">**Each unit depends on the research question.**</li>
</ol>

:::
:::

:::

:::



::::

:::: row

::: col-7

```{r}
#| echo: true

iris_1
```


:::

::: col-5

```{r}
#| echo: true

iris_2
```


:::

::::

:::::


::: notes

Consider `iris`—each row is one flower with four morphological measurements (sepal length, sepal width, petal length, petal width). This is tidy for the question: **"What morphological features distinguish these species?"**

Could you pivot `iris` longer with columns for `flower_part` (sepal/petal) and `measurement_type` (length/width)? Yes. Would it be tidy? Also yes—but for a different question: **"What determines the size of flower parts in general?"**

**The key distinction:** Are your columns measuring different variables or different levels of the same variable?

- **Different variables** → Keep separate columns
- **Different levels** → Pivot longer

Tidiness isn't absolute. It's defined by your analytical question. The same dataset can be tidy in multiple forms depending on what you're studying.

:::

## Data Preparation Terms

::: {style="font-size: .9em"}

| Process | Start State | Goal | End State | Examples |
|-----|-----|-----|-----|-----------|
| **Data Cleaning:** <br> Error correction | [Raw data]{.fragment fragment-index="1"} | [Accuracy, consistency, legibility]{.fragment fragment-index="2"} | [Clean data, not yet specialized]{.fragment fragment-index="3"} | [Removing duplicate data<br>Correcting syntax errors<br>Fixing typos<br>Handling missing values<br>Change data types]{.fragment fragment-index="4"} |
| **Data Wrangling:**  <br> Data preparation | [Clean data]{.fragment fragment-index="5"} | [Usability for medium-scope purpose]{.fragment fragment-index="6"} | [Interpretable and specialized data, not yet analyzable]{.fragment fragment-index="7"} | [Preparing for narrow use cases<br>Grouping and summarizing<br>Transforming variables or values]{.fragment fragment-index="8"} |
| **Data Transformation:**  <br> Data restructuring | [Interpretable data]{.fragment fragment-index="9"} | [Usability for narrow-scope tasks]{.fragment fragment-index="10"} | [Analyzable and visualizable data]{.fragment fragment-index="11"} | [Reshaping long ↔ wide<br>Generating new data-based variables<br>Merging datasets<br>Eliminating unnecessary data]{.fragment fragment-index="12"} |

:::

::: bubble-chain
<p class="bubble-left fragment">You use them differently in the core project instructions!</p>
<p class="bubble-left fragment">Those are the same thing!</p>
<p class="bubble-left fragment">That's not what I learned!</p>
<p class="bubble-right fragment">**OK FINE. Yes. You're all correct.** You're also all incorrect. Honestly it doesn't really matter. Just mess with your data until they are usable. Call it what you want as long as it works.</p>
:::

# Tidyverse Packages

::: {.r-stretch style="display: grid; grid-template-columns: repeat(4, 1fr); grid-template-rows: minmax(0, 1fr) minmax(0, 1fr); gap: 0.8em; padding-bottom: 1em;"}

::: {.contained-box .accent1 .fragment style="display: flex; flex-direction: column; align-items: center;"}

::: {.box-icon style="margin-bottom: 0.1em;"}

![](../images/icons/tv-icons/tibble.png){style="max-height: 2em;"}
:::

::: {.box-title style="font-size: 0.9em; margin-bottom: 0.2em;"}

::: {style="margin-bottom: -.4em !important; margin-top: -.4em !important;"}

[tibble]{.pkg}

:::

:::

::: {.box-content style="text-align: center;"}

Reimagine the dataframe

:::

:::

::: {.contained-box .accent1 .fragment style="display: flex; flex-direction: column; align-items: center;"}


::: {.box-icon style="margin-bottom: 0.1em;"}

![](../images/icons/tv-icons/readr.png){style="max-height: 2em;"}

:::

::: {.box-title style="font-size: 0.9em; margin-bottom: 0.2em;"}

::: {style="margin-bottom: -.4em !important; margin-top: -.4em !important;"}

[readr]{.pkg}

:::

:::

::: {.box-content style="text-align: center;"}

import and export tabular data

:::

:::

::: {.contained-box .accent1 .fragment style="display: flex; flex-direction: column; align-items: center;"}

::: {.box-icon style="margin-bottom: 0.1em;"}

![](../images/icons/tv-icons/dplyr.png){style="max-height: 2em;"}

:::

::: {.box-title style="font-size: 0.9em; margin-bottom: 0.2em;"}

::: {style="margin-bottom: -.4em !important; margin-top: -.4em !important;"}

[dplyr]{.pkg}

:::

:::

::: {.box-content style="text-align: center;"}

a grammar of data manipulation

:::

:::

::: {.contained-box .accent1 .fragment style="display: flex; flex-direction: column; align-items: center;"}

::: {.box-icon style="margin-bottom: 0.1em;"}

![](../images/icons/tv-icons/tidyr.png){style="max-height: 2em;"}

:::

::: {.box-title style="font-size: 0.9em; margin-bottom: 0.2em;"}

::: {style="margin-bottom: -.4em !important; margin-top: -.4em !important;"}

[tidyr]{.pkg}

:::

:::

::: {.box-content style="text-align: center;"}

tidy your messy data

:::

:::

::: {.contained-box .fragment style="display: flex; flex-direction: column; align-items: center;"}

::: {.box-icon style="margin-bottom: 0.1em;"}

![](../images/icons/tv-icons/purrr.png){style="max-height: 2em;"}

:::

::: {.box-title style="font-size: 0.9em; margin-bottom: 0.2em;"}

::: {style="margin-bottom: -.4em !important; margin-top: -.4em !important;"}

[purrr]{.pkg}

:::

:::

::: {.box-content style="text-align: center;"}

enhance R's functional programming

:::

:::

::: {.contained-box .fragment style="display: flex; flex-direction: column; align-items: center;"}

::: {.box-icon style="margin-bottom: 0.1em;"}

![](../images/icons/tv-icons/stringr.png){style="max-height: 2em;"}

:::

::: {.box-title style="font-size: 0.9em; margin-bottom: 0.2em;"}

::: {style="margin-bottom: -.4em !important; margin-top: -.4em !important;"}

[stringr]{.pkg}

:::

:::

::: {.box-content style="text-align: center;"}

simplify working with strings

:::

:::

::: {.contained-box .fragment style="display: flex; flex-direction: column; align-items: center;"}

::: {.box-icon style="margin-bottom: 0.1em;"}

![](../images/icons/tv-icons/forcats.png){style="max-height: 2em;"}

:::

::: {.box-title style="font-size: 0.9em; margin-bottom: 0.2em;"}

::: {style="margin-bottom: -.4em !important; margin-top: -.4em !important;"}

[forcats]{.pkg}

:::

:::

::: {.box-content style="text-align: center;"}

simplify working with factors

:::

:::

::: {.contained-box .fragment style="display: flex; flex-direction: column; align-items: center;"}

::: {.box-icon style="margin-bottom: 0.1em;"}

![](../images/icons/tv-icons/ggplot2.png){style="max-height: 2em;"}

:::

::: {.box-title style="font-size: 0.9em; margin-bottom: 0.2em;"}

::: {style="margin-bottom: -.4em !important; margin-top: -.4em !important;"}

[ggplot2]{.pkg}

:::

:::

::: {.box-content style="text-align: center;"}

a grammar of graphics

:::

:::

:::


# `tibble`

## `tibble`: Better Data Frames {.left-sidebar-slide fullscreen=true}

![](../images/icons/tv-icons/tibble.png){.absolute top="1em" right="1em" height="4em;"})


::: sidebar-column
::: sidebar-title

[tibble]{.pkg}: <br>Better Data Frames

:::

::: {.sidebar-content style="font-size: .8em"}

-   Adaptation of base R's `data.frame` 
-   Tibbles are *also* data.frames 
    -   Check with `class()` or `str()`
-   Tidyverse functions work with tibbles
    -   usually add the `tibble` class automatically
-   Functionally equivalent

:::

:::

::: main-content

::: {.r-stack}

![](../images/screenshots/iris-tabular.png){.fragment style="position: absolute; width: 60%; top: 2em; left: 2em;"}

![](../images/screenshots/iris-dataframe.png){.fragment style="position: absolute; width: 60%; top: 50%; left: 50%; transform: translate(-50%, -50%);"}

![](../images/screenshots/iris-tibble.png){.fragment style="position: absolute; width: 60%; bottom: 2em; right: 2em;"}

:::

:::

::: notes

Adaptation of base R's data.frame structure that makes a lot of things easier
Tibbles are also data.frames (check the class() or str() functions)
Tidyverse package(s) work with tibbles, not base data.frames
Load the tidyverse library to use tibble-related functions

:::

## `tibble`: implicit `data`

![](../images/icons/tv-icons/tibble.png){.absolute top="-1.5em" right="0em" height="4em;"}

-   Most Tidyverse functions *take* and *return* tibbles
    -   Notably `dplyr`, `tidyr`, and `ggplot2`
    -   Tibble is the required first argument (i.e., `data`)
-   As standalone functions, these require an explicit tibble argument:
    -   1st arg: `function(my_tbl, arg1, arg2)`
    -   Anywhere: `function(arg1, arg2, data = my_tbl)`
-   In *pipelines* using (`%>%` or `|>`), the tibble is implicit (omitted)
    -   Tibble output from `function1()` pipes `|>` to tibble input for `function2()`
    -   `function1(data, arg1, arg2) %>% function2(arg1, arg2)`

::: {.callout-tip .large .fragment}

### More on pipes later

More on the pipe operator and pipelines later. For now, know that when these slides show non-executed examples as `function(arg1, arg2)` as shorthand for `function(data, arg1, arg2)`.

:::

::: notes

The first argument for most tidyverse functions is `data`, the `tbl` passed to the function.

When running a tidyverse function on its own, you must include the tibble explicitly as a required argument either unnamed in the first position (`function(my_tbl, arg1, arg2)`) or anywhere by name (`function(arg1, arg2, data = my_tbl)`).

However, tidyverse functions are often used in a *pipeline* where the tibble is passed from one function to the next using a pipe operator (`%>%` or `|>`). Since tidyverse functions both *take* and *return* a tibble, the pipe automatically passes the output of one function as the first argument (`data`) of the next function in the chain, letting you omit it.

More on the pipe later. For now, know that when these slides show non-executed examples as `function(arg1, arg2)` as shorthand for `function(data, arg1, arg2)`.

::: 

# `readr`

## `readr`: Read & Write Tibbles {.left-sidebar-slide fullscreen=true}

![](../images/icons/tv-icons/readr.png){.absolute top="1em" right="1em" height="4em;"})


::: sidebar-column
::: sidebar-title

[readr]{.pkg}: <br> Read & Write Tibbles

:::
::: {.sidebar-content style="font-size: .8em"}

-   Import/export tabular data as tibbles
-   Functions start with `read_*()` and `write_*()`
-   Handle common file types: CSV, TSV, delimited, fixed-width
-   Other packages for Excel, SPSS, Google Sheets, JSON, databases

:::
:::

::: main-content

![](../images/screenshots/readr-specify.png){style="position: absolute; width: 80%; top: 50%; left: 50%; transform: translate(-50%, -50%);"}

:::


## What & Where

![](../images/icons/tv-icons/readr.png){.absolute top="-1.5em" right="0em" height="4em;"}

::::: container-fluid

::: {.row .d-flex }

::: {.col-6 .d-flex }

::: {.overlap-box .h-100 .w-100 .d-flex .flex-column}

::: box-title

Determine import function:

:::

::: {.box-content .flex-grow-1}

-   File extension?
-   Field separators?
-   Column names?
-   Non-tabular content?
-   Multiple sheets?

:::
        
:::

:::

::: {.col-6 .d-flex }

::: {.overlap-box .accent1 .h-100 .w-100 .d-flex .flex-column}

::: box-title

Determine file path:

:::

::: {.box-content .flex-grow-1}

-   Located in your repo
-   Protected data
    -   Add to `.gitignore` or `localonly`
    -   Only call in your *local* R scripts
-   Shared data
    -   In git-managed directory
    -   Callable by any/all scripts
-   Use relative paths

:::
        
:::
:::

::::

:::::


## Relative relativity

::: {.card style="font-size: 1.1em; font-weight: bolder; text-align: center; border-width:8px; border-color: #c00; flex: 1 1 100%; background-color: #ffeaa9; margin-bottom: 1.5em;"}

::: {.card-body style="display: flex; align-items: center; justify-content: center; gap: .1em;"}

![](../images/icons/priority.png){style="max-height: 3em;"}

Quarto documents handle relative paths differently than R scripts. 

![](../images/icons/priority.png){style="max-height: 3em;"}

:::

:::

In scripts, relative paths are relative to *the working directory*, your repo or project's top-level. In Quarto docs, relative paths are relative to *the location of the Quarto file itself*.

If you work in a single `.qmd` in the top-level of your repo, these are equivalent. Read from: `repo_name/data/file.csv`
    
If your `.qmd` is in any subfolder, you'll need to adjust. To read the same file from a code chunk in `repo_name/quarto/document.qmd`, use: `../data/file.csv`

This is for *all* file operations, not just `readr` functions.


::: aside
[`readr` cheatsheet](https://github.com/rstudio/cheatsheets/blob/main/data-import.pdf)
:::


## Importing with `readr` {.left-sidebar-slide fullscreen=true}

![](../images/icons/tv-icons/readr.png){.absolute top="1em" right="1em" height="4em;"})

::: sidebar-column
::: sidebar-title
**Importing** with [readr]{.pkg}: `read_*()`
:::

::: sidebar-content

-   `read_*()` import tabular data as tibbles
-   Optional `col_types` & `col_names` arguments:
-   Assign to object to save imported data

:::

:::

::: {.main-content style="padding-right: 5em;"}


```{.r style="margin-bottom: .5em"}
# Common read functions

read_csv()    # Comma separated values
read_csv2()   # Semicolon separator (comma = decimal)
read_tsv()    # Tab separated values
read_delim()  # Any delimiter
read_fwf()    # Fixed width files
read_table()  # Whitespace separated
```


```{.r code-line-numbers="1|2-3|5-9|11-14"}

# Default behavior - guesses all data types
my_tbl <- read_*(file.csv, col_types = NULL)

# Specify columns with cols()
my_cols <- read_*(file.csv, col_types = cols(
  my_factor = col_factor(),
  your_string = col_character()
))

# String shortcut:
# needs character for each col in order
# Use "?" for columns to guess
my_shortcut <- read_*(file.csv, col_types = "fc")
```

:::

## Exporting with `readr` {.left-sidebar-slide fullscreen=true}

![](../images/icons/tv-icons/readr.png){.absolute top="1em" right="1em" height="4em;"})

::: sidebar-column
::: sidebar-title
**Exporting** with [readr]{.pkg}: `write_*()`
:::

::: sidebar-content

::: {.tightlist}

-   `read_*()` functions have matched `write_*()` counterparts
-   Save tibbles to tabular files
-   Write *intermediate datasets* after:
    -   De-identifying data
    -   Complex wrangling
    -   Dropping unneeded data
    -   Managing empty data
-   Run from script or console, no object assignment

:::

:::

:::

::: {.main-content style="padding-right: 5em;"}

```{.r style="margin-bottom: .5em"}
# Common write_*() functions

write_delim()
write_csv()
write_csv2()
write_excel_csv()
write_excel_csv2()
write_tsv()
```


```{.r code-line-numbers="1|2-4|6|8-11|12,13"}

# Start with messy data
messy_df <- read_xlsx("localpath/messy.xlsx", 
                     sheet="my sheet")

# Process in R: tidy, clean, transform...

# Export clean version
clean_df <- # ... your cleaning steps
write_csv(clean_df, "localpath/clean.csv")

# Later, read the clean version
clean_df <- read_csv("localpath/clean.csv")

```


:::

::: notes

Export tibbles to create intermediate datasets between initial import and final analysis
Easily produce de-identified datasets to share with others
Save computational time by skipping costly read-in and wrangling steps (e.g., big files, many files, complex transformations)
readr can also export tibbles to tabular files with similar syntax to how it imports

:::

## {fullscreen=true}

::: {.container-fluid style="position: absolute; width: 95vw; top: 50%; left: 50%; transform: translate(-50%, -50%);"}

::: {.row}

::: {.col-3 .fragment fragment-index="1"}

![](../images/screenshots/process-messy-file.png){style="max-width: 120% !important; margin-top: 0em" alt="Messy Data File"}


:::

::: {.col-1 .fragment fragment-index="2"}

::: {style="text-align: center; margin-top: 50%;"}
::: {style="font-size: 2em"}
{{< bi arrow-right-circle-fill>}}
:::
:::
:::

::: {.col-4 .smaller .fragment fragment-index="2"}

```{.r}
# Read in messy data
messy_df <- read_xlsx(
    "localpath/messy.xlsx",
    sheet="my sheet"
    )
```

:::

::: {.col-1 .fragment fragment-index="3"}

::: {style="text-align: center; margin-top: 50%;"}
::: {style="font-size: 2em"}
{{< bi arrow-right-circle-fill >}}
:::
:::

:::

::: {.col-3 .smaller .fragment fragment-index="3"}

![](../images/icons/cleaning.png){style="max-height: 3.5em;" alt="Clean"} ![](../images/icons/lasso.png){style="max-height: 3.5em;" alt="Wrangle"}



:::

:::



<!-- open down arrow row -->

::: row

::: {.col-11 style="text-align: right;" .fragment fragment-index="4"}

::: {style="font-size: 2em"}
{{< bi arrow-down-circle-fill >}}
:::

:::


::: col-1

[.]{style="font-size: 0em;"}

:::

:::

<!-- close down arrow row -->


<!-- open second row -->

::: row

<!-- open tidy data card column -->
::: {.col-3 .smaller  .fragment fragment-index="6"}

::: {.card}

::: card-header
::: {.card-title style="color: #fff; font-size: .8em"}

My tidy data file:

:::
:::

::: {.card-body .lessgap style="font-size: .8em" .nonincremental}

-   Data needed for future R scripts *and nothing else*
-   Minimal, tabular (.csv)
-   No protected data
-   Added variables from initial wrangling

:::
:::

:::

<!-- close tidy data card column -->

<!-- open circular paths column -->

::: col-6



<!-- open left path row -->

::: {.row .fragment fragment-index="5"}

::: {.col-2 .fragment fragment-index="6"}

::: {style="text-align: center; "}
::: {style="font-size: 2em"}
{{< bi arrow-left-circle-fill >}}
:::
:::

:::

::: {.col-8 .smaller}

```{.r}
# Write out clean version
write_csv(clean_df, 
          "localpath/clean.csv")
```

:::

::: {.col-2}

::: {style="text-align: center;"}
::: {style="font-size: 2em"}
{{< bi arrow-left-circle-fill >}}
:::

:::

:::

:::

<!-- close left path row -->

<!-- open right path row -->

::: {.row style="margin-top: 1em;" .fragment fragment-index="7"}

::: {.col-2}

::: {style="text-align: center;"}
::: {style="font-size: 2em"}
{{< bi arrow-right-circle-fill >}}
:::
:::

:::

::: {.col-8 .smaller}

```{.r}
# Read in clean version
clean_df <- read_csv(
    "localpath/clean.csv")
```

:::

::: {.col-2}

::: {style="text-align: center;"}
::: {style="font-size: 2em"}
{{< bi arrow-right-circle-fill >}}
:::
:::

:::

:::

<!-- close right path row -->

:::

<!-- close circular paths column -->

<!-- open clean_df column -->

::: {.col-3 .fragment fragment-index="4"}


::: {.card .card-accent1 style="padding:0px"}

::: card-header
::: {.card-title style="color: #fff; font-size: .6em"}

`clean_df`:

:::
:::

::: {.card-body .lessgap style="font-size: .8em" .nonincremental}

-   Clean & tidy tibble
-   Data needed for analysis *and nothing else*

:::
:::

:::


<!-- close clean_df column -->

:::

<!-- close second row column -->

:::

<!-- close container -->


## Bonus: `readxl` & `googlesheets4`

![](../images/icons/tv-icons/readxl.png){.absolute top="-1.5em" right="4em" height="4em;"}
![](../images/icons/tv-icons/googlesheets4.png){.absolute top="-1.5em" right="0em" height="4em;"}

::: {.callout-note .large}

### Complementary packages to `readr`

- Mimic readr's [read_*]{.func} functions
    -   [same cheatsheet](https://github.com/rstudio/cheatsheets/blob/main/data-import.pdf)
- Specification for converting "complex" documents into a `tbl`-compatible format
- *Not* tidyverse packages
    - Install and load them separately!

:::

::: fragment

```{.r}
# readxl for Excel files
library(readxl)
read_excel("data.xlsx")

# googlesheets4 for Google Sheets
library(googlesheets4)
read_sheet("spreadsheet_url")
```
:::

## Practice: Read & Write (1)

::::: container-fluid

:::: row

::: col-5

::: overlap-box

::: box-title

Read in M&M data:

:::

::: box-content

1. Pull the `student-hub` repo (or find files on GitHub)
2. Find the Excel spreadsheet: `data/MM data.xlsx`
3. Install and load the [readxl]{.pkg} library
4. Use the `read_excel()` function to assign the data to a tibble called `mmdata`
5. Examine your data in the console to see if it matches the image

:::
        
:::

:::

::: col-7

![](../images/screenshots/mmdata-goal.png)

:::

::::

:::::


::: bubble-chain
  <p class="bubble-left fragment">It doesn't!</p>
  <p class="bubble-right fragment">Oh no! Thank heavens you are smarter than a computer.</p>
:::



## Practice: Read & Write (2)

::::: container-fluid

:::: row

::: col-7

::: overlap-box

::: box-title

Fix, read, write:

:::

::: box-content

1. Open `MM data.xlsx` in Excel (or similar) and examine it with your human eyeballs
    -   What about this file creates problems when you read-in?
    -   How might you fix the issue here in the Excel document? 
2. Review the `?read_excel` documentation 
    -   What arguments can you pass to `read_excel()` to fix the issue on read-in?
3. Use `read_excel()` to assign the data to a tibble called `mmdata` that looks like the image
4. Use `write_csv()` to save `mmdata` to an intermediate dataset at the location `student-hub/data/mmdata.csv`
    -   Use an appropriate relative path!


:::
        
:::

:::

::: col-5

![](../images/screenshots/mmdata-goal.png)

:::

::::

:::::


::: bubble-chain
  <p class="bubble-left fragment">It says that folder doesn't exist! <br> *(and/or)* <br> It doesn't read/write/both where I want it to!
</p>
  <p class="bubble-right fragment">Remember relative relativity. Are you reading and writing from a script, Quarto doc, or the console?</p>
:::


::: notes

Open `MM data.xlsx` in Excel (or similar) and examine it with your human eyeballs
What about this file creates problems when you read-in?
How would you fix the issue here in the Excel document? (just think; don't do it!)
Review the ?read_excel documentation 
What arguments can you pass to read_excel() to fix the issue on read-in?
Use the read_excel() function to assign the data to a tibble called mmdata that looks like the image
Use write_csv() to save mmdata to an intermediate dataset: `in-class-materials/data/mmdata.csv`

:::


# `dplyr`


## `dplyr`: Data Transformation {.left-sidebar-slide fullscreen=true}

![](../images/icons/tv-icons/dplyr.png){.absolute top="1em" right="1em" height="4em;"})


::: sidebar-column
::: sidebar-title

[dplyr]{.pkg}: <br> Grammar of Data Manipulation

:::
::: sidebar-content

-   Core tidyverse package for data transformation
-   Works with tibbles (and data.frames)
-   First argument always `data` (the tibble to transform)

:::
:::

::: main-content

::: {.r-stretch style="display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: minmax(0, 1fr) minmax(0, 1fr); gap: 0.8em; margin-top: 3em;"}

::: {.contained-box .fragment style="display: flex; flex-direction: column; align-items: center; padding: 0.4em 0.3em 0.2em 0.3em;"}

::: {.box-icon style="margin-bottom: 0.1em;"}

{{< bi check2-square>}}

:::

::: {.box-title style="font-size: 0.9em; margin-bottom: 0.2em;"}

::: {style="margin-bottom: -.4em !important; margin-top: -.4em !important;"}

[select]{.func}

:::

:::

::: {.box-content style="text-align: center;"}

subset & sort columns

:::

:::

::: {.contained-box .fragment style="display: flex; flex-direction: column; align-items: center; padding: 0.4em 0.3em 0.2em 0.3em;"}

::: {.box-icon style="margin-bottom: 0.1em;"}

{{< bi funnel>}}

:::

::: {.box-title style="font-size: 0.9em; margin-bottom: 0.2em;"}

::: {style="margin-bottom: -.4em !important; margin-top: -.4em !important;"}

[filter]{.func}

:::

:::

::: {.box-content style="text-align: center;"}

subset rows

:::

:::

::: {.contained-box .fragment style="display: flex; flex-direction: column; align-items: center; padding: 0.4em 0.3em 0.2em 0.3em;"}

::: {.box-icon style="margin-bottom: 0.1em;"}

{{< bi layer-backward>}}

:::

::: {.box-title style="font-size: 0.9em; margin-bottom: 0.2em;"}

::: {style="margin-bottom: -.4em !important; margin-top: -.4em !important;"}

[arrange]{.func}

:::

:::

::: {.box-content style="text-align: center; overflow: hidden; min-height: 0; font-size: 0.9em; line-height: .9;"}

sort rows

:::

:::

::: {.contained-box .fragment style="display: flex; flex-direction: column; align-items: center; padding: 0.4em 0.3em 0.2em 0.3em;"}

::: {.box-icon style="margin-bottom: 0.1em;"}

{{< bi node-plus-fill>}}

:::

::: {.box-title style="font-size: 0.9em; margin-bottom: 0.2em;"}

::: {style="margin-bottom: -.4em !important; margin-top: -.4em !important;"}

[mutate]{.func}

:::

:::

::: {.box-content style="text-align: center;"}

create and modify columns

:::

:::

::: {.contained-box .fragment style="display: flex; flex-direction: column; align-items: center; padding: 0.4em 0.3em 0.2em 0.3em;"}

::: {.box-icon style="margin-bottom: 0.1em;"}

{{< bi calculator>}}

:::

::: {.box-title style="font-size: 0.9em; margin-bottom: 0.2em;"}

::: {style="margin-bottom: -.4em !important; margin-top: -.4em !important;"}

[summarize]{.func}

:::

:::

::: {.box-content style="text-align: center;"}

compute with multiple rows

:::

:::

::: {.contained-box .fragment style="display: flex; flex-direction: column; align-items: center; padding: 0.4em 0.3em 0.2em 0.3em;"}

::: {.box-icon style="margin-bottom: 0.1em;"}

{{< bi collection>}}

:::

::: {.box-title style="font-size: 0.9em; margin-bottom: 0.2em;"}

::: {style="margin-bottom: -.4em !important; margin-top: -.4em !important;"}

[group_by]{.func}

:::

:::

::: {.box-content style="text-align: center;"}

perform operations on subgroups

:::

:::


:::

:::

```{r}
#| include: false
#| echo: false

mm.sample <- head(mm.raw, 5)
```


## `select`: Subset columns {style="font-size: .8em"}

![](../images/icons/tv-icons/dplyr.png){.absolute top="-1.5em" right="0em" height="4em;"}

::::: container-fluid

:::: row

::: col-6

::: {.overlap-box}

::: box-title

Include/exclude syntax:

:::

::: box-content

```{.r}
select(tbl, col1, col2, ...)
```

::: {.nonincremental .fragment fragment-index="1"}
-   Column names are objects, not strings
    -   `select(mm.sample, Bag, Red)`
    -   *not* `select(mm.sample, "Bag", "Red")`

:::

::: {.nonincremental .fragment fragment-index="2"}
-   Include (default): 
    -   `select(col1, col2)`

:::

::: {.nonincremental .fragment fragment-index="3"}
-   Exclude with `-`:
    -   `select(-col3, -col4)`
    -   `select(-c(col3, col4))`
    
:::

::: {.nonincremental .fragment fragment-index="4"}
-   Use ranges:
    -   Name: `select(colA:colC)`
    -   Position: `select(1:3)`
    -   Exclude: `select(-(4:6))`

:::
        
:::

:::

:::

::: {.col-6 style="margin-top: 1em"}

::: {.fragment fragment-index="5"}
```{.r}
# Include specific columns 
select(mm.sample, Bag, Red, Green, Blue)

# Exclude specific columns
select(mm.sample, -Orange, -Yellow, -Brown, -Weight)

# Exclude list of columns
select(mm.sample, -c(Orange, Yellow, Brown, Weight))

# Include columns by name range
select(mm.sample, Bag:Blue)

# Exclude columns by position range
## `-` requires range in `()`
select(mm.sample, -(5:8))
```
:::

::: {.fragment fragment-index="6" style="margin-top: 1em;"}
```{r}
#| echo: false
select(mm.sample, Bag, Red, Green, Blue)
```
:::

:::

::::

:::::








## `select`: Rename & reorder columns {style="font-size: .8em"}

![](../images/icons/tv-icons/dplyr.png){.absolute top="-1.5em" right="0em" height="4em;"}

::::: container-fluid

:::: row

::: col-4

::: overlap-box

::: box-title

Rename & order:

:::

::: box-content

::: {.nonincremental .fragment fragment-index="1"}
-   Select & reorder:
    -   `select(col3, col1, col2)`
:::

::: {.nonincremental .fragment fragment-index="2"}
-   Select & rename:
    -   `select(new_name = old_name)`
:::

::: {.nonincremental .fragment fragment-index="3"}
-   Backticks for special characters:
    -   ``select(`col 2 (two)` = col2)``
:::

::: {.nonincremental .fragment fragment-index="4"}
-   Related function: [rename()](https://dplyr.tidyverse.org/reference/rename.html){.func}
    -   Rename some or all columns
    -   Retain *all* columns *in original order*
:::

::: {.nonincremental .fragment fragment-index="5"}
-   Related function: [relocate()](https://dplyr.tidyverse.org/reference/relocate.html){.func}
    -   Move columns to relative positions
    -   `relocate(col3, .before = col1)`
    -   Retain *all* columns *in original order*
:::
        
:::

:::

:::

::: col-3

::: {.fragment style="margin-top: .2em;" fragment-index="1"}
```{r}
# Select and reorder
select(mm.sample, 
       Green, Blue, Bag, Red)
```
:::

::: {.fragment style="margin-top: .2em;" fragment-index="2"}
```{r}
# Select and rename
select(mm.sample, 
       Bag, rojo = Red, 
       vert = Green, 
       `aoi 青` = Blue)
```
:::

:::

::: col-5

::: {.fragment style="margin-top: .2em;" fragment-index="3"}
```{r}
# Select, reorder, rename
select(mm.sample, 
       vert = Green, 
       rojo = Red, 
       `aoi 青` = Blue, 
       Bag)
```
:::

::: {.fragment style="margin-top: .2em;" fragment-index="4"}
```{r}
# Rename w/out select or reorder
rename(mm.sample, 
       vert = Green, 
       rojo = Red, 
       `aoi 青` = Blue)
```
:::

:::

::::

:::::



## `select` Helpers

![](../images/icons/tv-icons/dplyr.png){.absolute top="-1.5em" right="0em" height="4em;"}

::::: container-fluid

:::: row

::: col-4

::: overlap-box

::: box-title

[tidy-select](https://tidyselect.r-lib.org/reference/index.html){style="color: #F8FdFE"}

:::

::: box-content

::: {.nonincremental .fragment fragment-index="1"}
-  `starts_with("prefix")`
:::

::: {.nonincremental .fragment fragment-index="2"}
-  `ends_with("suffix")`
:::

::: {.nonincremental .fragment fragment-index="3"}
-  `contains("text")`
:::

::: {.nonincremental .fragment fragment-index="4"}
-  `matches("regex")`
:::

::: {.nonincremental .fragment fragment-index="5"}
-  `num_range("x", 1:5)`
:::

::: {.nonincremental .fragment fragment-index="6"}
-  `everything()`
:::
        
:::

:::

:::

::: {.col-4 style="margin-top: -2em"}

::: {.fragment style="margin-top: .2em;" fragment-index="1"}
```{r}
# Select by first character(s)
select(mm.sample, 
       starts_with("B"))
```
:::

::: {.fragment style="margin-top: .2em;" fragment-index="2"}
```{r}
# Select by last character(s)
select(mm.sample, 
       ends_with("n"))
```
:::

:::

::: {.col-4 style="margin-top: -2em"}

::: {.fragment style="margin-top: .2em;" fragment-index="3"}
```{r}
# Select with regex
select(mm.sample, 
       contains("ow"))
```
:::

::: {.fragment style="margin-top: .2em;" fragment-index="4"}
```{r}
# Select with regex
select(mm.sample, 
       matches("^B|n$"))
```
:::

:::

::::

:::::


::: notes

Operates on columns/variables (not observations/rows)
Returns a tibble with
only the given columns
in the order given
renamed if provided
Remove columns with the hyphen
Includes everything not explicitly mentioned
Rename as you select with new_name = old_name


:::


## `filter`: Subset rows

![](../images/icons/tv-icons/dplyr.png){.absolute top="-1.5em" right="0em" height="4em;"}

<!-- begin container -->
::::: container-fluid

<!-- begin main row -->
:::: row

<!-- begin left column -->
::: col-5

::: {.overlap-box .accent1}

::: box-title

Filter syntax & logic:

:::

::: box-content

```{.r}
filter(tbl, cond1, cond2, ...)
```


-   Operates on rows (observations)
-   Conditional evaluation:
    -   Comparison operators (e.g., `>`, `!=`, `==`)
    -   Logical operators (e.g., `&`, `|`, `!`)
    -   Boolean values (`TRUE`, `FALSE`)
-   Returns tibble with rows that meet *all* conditions


:::

:::

:::
<!-- End left column -->

<!-- Begin right column -->
::: {.col-7 style="margin-top: -3em; font-size: .8em;"}

```{r}
#| include: false
# Vehicle dataframe (1 column called `transport`)
vehicles <- data.frame(
    transport = c("walking", "bus", "bicycle", "car", "atv",
                   "motorcycle", "razor scooter", "the el", 
                   "jet ski", "sailboat", "tricycle", "chariot")
)
# Condition 1
condition1 <- c("bicycle")

# Condition 2
condition2 <- c("bicycle", "atv", "motorcycle", "razor scooter", "jet ski", "atv")

# Condition 3
condition3 <- c("boat")

# Condition 4
condition4 <- c("bus", "bicycle", "car", "motorcycle", "razor scooter", "jet ski")
```

```{r}
#| eval: false
#| echo: true
# Vehicle dataframe (1 column called `transport`)
vehicles <- data.frame(
    transport = c("walking", "bus", "bicycle", "car", "atv",
                   "motorcycle", "razor scooter", "the el", 
                   "jet ski", "sailboat", "tricycle", "chariot"))

# Condition 1
filter(vehicles, transport == "bicycle")

# Condition 2
filter(vehicles, 
       has.handlebars(transport) | transport == "boat")

# Condition 3
filter(vehicles, 
       has.handlebars(transport), transport == "boat")

# Condition 3
filter(vehicles, 
       (has.handlebars(transport) & n.wheels(transport) < 3) |
           (requires.gas(transport) & n.wheels(transport) > 3))
```

<!-- Begin conditional results row -->
::: row

::: {.col-3 .fragment}

Condition 1:

```{r}
#| echo: false
filter(vehicles, transport %in% condition1)
```

:::

::: {.col-3 .fragment}

Condition 2:

```{r}
#| echo: false
filter(vehicles, transport %in% condition2)
```

:::

::: {.col-3 .fragment}

Condition 3:

```{r}
#| echo: false
filter(vehicles, transport %in% condition2, transport == "boat")
```

:::

::: {.col-3 .fragment}

Condition 4:

```{r}
#| echo: false
filter(vehicles, transport %in% condition4)
```

:::

:::
<!-- End conditional results row -->

:::
<!-- End right column -->

::::
<!-- end main row -->

:::::
<!-- end container -->

::: notes

Operates on observations/rows (not columns!)
Conditions are logical evaluations using:
>, >=, <, <=, != (“not equal to”), and == (“equal to”)
If the condition evaluates to TRUE, it stays and is returned or passed to the next line of the pipe
If FALSE, it's filtered out

:::




## `filter`: Subset rows

![](../images/icons/tv-icons/dplyr.png){.absolute top="-1.5em" right="0em" height="4em;"}

<!-- begin container -->
::::: container-fluid

<!-- begin main row -->
:::: row

<!-- begin left column -->
::: col-5

::: {.overlap-box .accent1}

::: box-title

Filter example:

:::

::: {.box-content .nonincremental}
```{r style="font-size: .9em"}
#| eval: false
#| echo: true

# Condition 1
filter(mm.tidy, Bag_Weight > 50)

# Condition 2
filter(mm.tidy, 
       Color == "Red" | Number >= 15)

# Condition 3
filter(mm.tidy, 
       Color == "Red", Number >= 15)

# Condition 4
filter(mm.tidy, 
       (Color == "Blue" & Number >= 5) |
           (Bag_Weight > 50.5 | Bag_Weight < 47),
       Bag != 6)
```

:::

:::

:::
<!-- End left column -->

<!-- Begin right column -->
::: {.col-7 style="margin-top: -3em; font-size: .8em;"}

<!-- Begin conditional results row 1 -->
::: row

::: {.col-6 .fragment}

Condition 1:

```{r}
#| echo: false
# Condition 1
filter(mm.tidy, Bag_Weight > 50)
```

:::

::: {.col-6 .fragment}

Condition 2:

```{r}
#| echo: false
# Condition 2
filter(mm.tidy, 
       Color == "Red" | Number >= 15)
```

:::

:::
<!-- End conditional results row 1

<!-- Begin conditional results row 2 -->
::: row

::: {.col-6 .fragment}

Condition 3:

```{r}
#| echo: false
# Condition 3
filter(mm.tidy, 
       Color == "Red", Number >= 15)
```

:::

::: {.col-6 .fragment}

Condition 4:

```{r}
#| echo: false
# Condition 4
filter(mm.tidy, 
       (Color == "Blue" & Number >= 5) |
           (Bag_Weight > 50.5 | Bag_Weight < 47),
       Bag != 6)
```

:::

:::
<!-- End conditional results row 2 -->

:::
<!-- End right column -->

::::
<!-- end main row -->

:::::
<!-- end container -->

::: notes

Operates on observations/rows (not columns!)
Conditions are logical evaluations using:
>, >=, <, <=, !=, ==
If the condition evaluates to TRUE, it stays and is returned or passed to the next line of the pipe
If FALSE, it's filtered out

:::



## `arrange`: Sort rows

![](../images/icons/tv-icons/dplyr.png){.absolute top="-1.5em" right="0em" height="4em;"}

::::: container-fluid

:::: row

::: col-4

::: overlap-box

::: box-title

Arrange syntax:

:::

::: box-content

```{.r}
arrange(tbl, col1, col2, ...)
```

-   Sort rows by column values
-   If 2+ variables, sorts in order given
-   Strings sorted alphabetically
-   Ascending order (default)
-   Descending order:
    -   `arrange(desc(col1))`
    -   `arrange(-col1)`
        
:::

:::

:::

::: {.col-4 style="font-size: .8em;"}

::: {.fragment style="margin-top: 1em;"}
```{r}
# Sort by (ascending) bag weight
arrange(mm.tidy, Bag_Weight)
```
:::

:::

::: {.col-4 style="font-size: .8em;"}

::: {.fragment style="margin-top: 1em;"}
```{r}
# Sort by color -> desc number -> desc bag
arrange(mm.tidy, Color, -Number, desc(Bag))
```
:::

:::

::::

:::::

::: notes

Sort rows of your tibble in the order of col1, then col2, etc.
Defaults to ascending order, but you can wrap the column name in the desc() function to use descending order
The hyphen - is shorthand for desc()

:::

## `mutate`: Create & modify columns {style="font-size: .8em"}

![](../images/icons/tv-icons/dplyr.png){.absolute top="-1.5em" right="0em" height="4em;"}

::::: container-fluid

:::: row

::: col-3

::: {.overlap-box .accent1}

::: {.box-title style="font-size: .9em"}
Create & modify:
:::

::: box-content

```{.r}
mutate(tbl, 
    new_col1 = ..., 
    new_col2 = ..., 
    ...)
```

-   Add named new column
-   Assign values with `=`
-   Compute values by row
-   Columns created in order
    -   Reference a newly created column in subsequent columns
-   Modify an existing column by creating a new column with the same name

:::

:::

:::


::: {.col-4 style="font-size: .8em, margin-top: -2em"}

::: {.fragment style="margin-top: 1em;"}

```{r}
# Create new column: Weight_Oz
# then pipe to select cols
mutate(mm.sample,
    Type = "Chocolate") |> 
    select(Bag, Weight, Type) 
```

:::

::: {.fragment style="margin-top: 1em;"}

```{r}
# Create new column: Weight_Oz
mutate(mm.sample,
    Weight_Oz = Weight / 28.34952) |> 
    select(Bag, Weight, Weight_Oz)
```

:::

:::

::: {.col-5 style="margin-top: -4.5em"}

::: {.fragment style="margin-top: 1em;"}

```{r}
# Create new column (total M&Ms per bag)
# Then another new column (proportion of red M&Ms)
# using the first new column
mutate(mm.sample,
    Total_MMs = Red + Green + Blue + 
        Brown + Yellow + Orange,
        Prop_Red = Red / Total_MMs) |> 
    select(Bag, Red, Total_MMs, Prop_Red)
```

:::

::: {.fragment style="margin-top: 1em;"}

```{r}
# Change values in existing column by overwriting
mutate(mm.sample,
        Weight = case_when(
        Weight < 48 ~ "Light",
        Weight > 50 ~ "Heavy",
        TRUE ~ "Medium" # anything left after
        )) |> 
select(Bag, Red, Weight)
```

:::

:::

::::

:::::

::: notes

Adds new column(s) with names and values that you define
Use the single equals sign to assign new values
Use double equal signs to mean "equals" within a conditional statement
*Use mutate to effectively change data in an existing variable by creating a new variable with the same name that will overwrite it


:::


## `summarize` & `group_by`: Compute summary values {style="font-size: .8em"}

![](../images/icons/tv-icons/dplyr.png){.absolute top="-1.5em" right="0em" height="4em;"}

::::: container-fluid

:::: row

::: col-4

::: {.overlap-box}

::: box-title
Group & summarize:
:::

::: box-content

```{.r}
group_by(tbl, col1, col2, ...)  |> 
summarize(
    summary_col1 = summary_func(colA),
    summary_col2 = summary_func(colB),
...)
```

-   `group_by()` creates subgroups based on unique values across 1+ columns
    -   Tidy `group`ing needs tidy data
-   `summarize()` computes summary functions across those groups
    -   e.g., `mean()`, `max()`, `last()`, `n()`
-   Output tibble includes:
    -   Grouping column(s)
    -   New summary column(s)


:::

:::

:::

::: col-4

```{r}
#| output-location: fragment
# Compute mean weight of all bags
summarize(mm.tidy, 
          Mean_Weight = mean(Bag_Weight))
```

```{r style="margin-top: .1em"}
#| output-location: fragment
# Group by color
group_by(mm.tidy, Color) |>  
# pipe grouped data to next function
# Compute total count and mean weight *per color*
summarize(Mean_Weight = mean(Bag_Weight),
          Total_Number = sum(Number))
```

:::

::: col-4
```{r}
#| include: false
# Grouping by multiple columns creates a summary value for each 
# unique combination of values in those columns
mm.tidy.weights <- mm.tidy |> 
    mutate(Weight_Class = case_when(
        Bag_Weight < 48 ~ "Light",
        Bag_Weight > 50 ~ "Heavy",
        TRUE ~ "Medium"
    ))
```

```{r}
#| output-location: fragment
# `mm.tidy.weights` includes a Weight_Class column
# Grouping by multiple columns creates a summary value for each 
# unique combination of values in those columns
group_by(mm.tidy.weights, Color, Weight_Class) |> 
summarize(Mean_Weight = mean(Bag_Weight),
          Total_Number = sum(Number))
```

:::

::::

:::::

::: notes

summarize() will compute a summary function (e.g., mean, maximum, last) across a variable
grouping your data first lets you summarize based on subsets within 1 or more columns
group_by() a categorical variable then pipe it into a summarize()
the resulting tibble will ONLY have the columns you created in the summarize()

In the example with both mean weight and total number of M&Ms, both summary values are computed for each color subgroup. Mean weight is identical for all colors; total number is not. Figure out why.

::: 


# `magrittr` & pipes

![](../images/comics-memes/une-pipe.png)

---

## The Pipe Operator(s)

![](../images/icons/tv-icons/dplyr.png){.absolute top="-1.5em" right="4em" height="4em;"}
![](../images/icons/tv-icons/magrittr.png){.absolute top="-1.5em" right="0em" height="4em;"}

[Pipes]{.keyword} create [pipelines]{.keyword}, human-readable alternative to multiple embedded functions.

::::: container-fluid
:::: row
::: fragment
```{.r}
as much as you like(change it with function Y(change it with function X(create some data)))
```
:::
::::

:::: {.row style="margin-top: 1em;"}

::: {.col-6 .fragment}

```{.r}
create some data |> 
    change it with function X |> 
    change it with function Y |> 
    as much as you like
```

:::

::: {.col-6 .fragment}

```{.r}
mm.tidy |> 
    group_by(Color) |> 
    summarize(Mean_Number = mean(Number)) |> 
    filter(Mean_Number < 10)
```

:::

::::

:::: row

::: {.callout-note .fragment}

### `|>` vs. `%>%`

[base]{.pkg} R has a native `|>` pipe. [magrittr]{.pkg} adds the `%>%` pipe for tidyverse use.

The `%>%` pipe was the standard for many years in the tidyverse. It is usable, maintained, and popular, but no longer necessary. 

As of R 1.4.0, `|>` is the [recommend pipe](https://r4ds.hadley.nz/data-transform.html#sec-the-pipe) for most uses. Now that it plays nicely with tidyverse pipelines, you can consistently just use `|>` whether you're working in the tidyverse or not. Updated D2M-R materials will use the `|>` pipe going forward, but older materials may still use `%>%`.

**Either works.**

:::

::::
:::::


## Pipe Example (1/8) {style="font-size: .8em"}

::: longer-code

```{r style="font-size: 1.1em;"}
#| message: false
#| warning: false
#| output-location: column
# Begin with mm.tidy
mm.tidy
```

:::

::: {visibility="uncounted"}
## Pipe Example (2/8) {.noframenumbering style="font-size: .8em"}

::: longer-code

```{r style="font-size: 1.1em;"}
#| message: false
#| warning: false
#| output-location: column
# Begin with mm.tidy
mm.tidy |>
    # Create new column: Primary_Color
    mutate(
        Color_Type = case_when(
            Color %in% c("Red", "Blue", "Yellow") ~ "Primary",
            TRUE ~ "Secondary"),    
        )
```

:::
:::


::: {visibility="uncounted"}
## Pipe Example (3/8) {.noframenumbering style="font-size: .8em"}

::: longer-code

```{r style="font-size: 1.1em;"}
#| message: false
#| warning: false
#| output-location: column
# Begin with mm.tidy
mm.tidy |>
    # Create new column: Primary_Color
    mutate(
        Color_Type = case_when(
            Color %in% c("Red", "Blue", "Yellow") ~ "Primary",
            TRUE ~ "Secondary"),    
        ) |> 
    # Group by color type & bag
    group_by(Color_Type, Bag)
```

:::
:::

::: {visibility="uncounted"}
## Pipe Example (4/8) {.noframenumbering style="font-size: .8em"}

::: longer-code

```{r style="font-size: 1.1em;"}
#| message: false
#| warning: false
#| output-location: column
# Begin with mm.tidy
mm.tidy |>
    # Create new column: Primary_Color
    mutate(
        Color_Type = case_when(
            Color %in% c("Red", "Blue", "Yellow") ~ "Primary",
            TRUE ~ "Secondary"),    
        ) |> 
    # Group by color type & bag
    group_by(Color_Type, Bag) |>
    # Summarize total M&Ms per group
    summarize(Total_Number = sum(Number))
```

:::
:::

::: {visibility="uncounted"}
## Pipe Example (5/8) {.noframenumbering style="font-size: .8em"}

::: longer-code

```{r style="font-size: 1.1em;"}
#| message: false
#| warning: false
#| output-location: column
# Begin with mm.tidy
mm.tidy |>
    # Create new column: Primary_Color
    mutate(
        Color_Type = case_when(
            Color %in% c("Red", "Blue", "Yellow") ~ "Primary",
            TRUE ~ "Secondary"),    
        ) |> 
    # Group by color type & bag
    group_by(Color_Type, Bag) |>
    # Summarize total M&Ms per group
    summarize(Total_Number = sum(Number)) |>
    # Arrange by bag then color_type
    arrange(Bag, Color_Type)
```

:::
:::

::: {visibility="uncounted"}
## Pipe Example (6/8) {.noframenumbering style="font-size: .8em"}

::: longer-code

```{r style="font-size: 1.1em;"}
#| message: false
#| warning: false
#| output-location: column
# Begin with mm.tidy
mm.tidy |>
    # Create new column: Primary_Color
    mutate(
        Color_Type = case_when(
            Color %in% c("Red", "Blue", "Yellow") ~ "Primary",
            TRUE ~ "Secondary"),    
        ) |> 
    # Group by color type & bag
    group_by(Color_Type, Bag) |>
    # Summarize total M&Ms per group
    summarize(Total_Number = sum(Number)) |>
    # Arrange by bag then color_type
    arrange(Bag, Color_Type) |> 
    # Pivot wider: one row per bag
    pivot_wider(
        names_from = Color_Type,
        values_from = Total_Number
    )
```

:::

::: notes

We haven't talked about pivot wider yet but it's coming up next!

:::

:::

::: {visibility="uncounted"}
## Pipe Example (7/8) {.noframenumbering style="font-size: .8em"}

::: longer-code

```{r style="font-size: 1.1em;"}
#| message: false
#| warning: false
#| output-location: column
# Begin with mm.tidy
mm.tidy |>
    # Create new column: Primary_Color
    mutate(
        Color_Type = case_when(
            Color %in% c("Red", "Blue", "Yellow") ~ "Primary",
            TRUE ~ "Secondary"),    
        ) |> 
    # Group by color type & bag
    group_by(Color_Type, Bag) |>
    # Summarize total M&Ms per group
    summarize(Total_Number = sum(Number)) |>
    # Arrange by bag then color_type
    arrange(Bag, Color_Type) |> 
    # Pivot wider: one row per bag
    pivot_wider(
        names_from = Color_Type,
        values_from = Total_Number
    ) |> 
    # Add column determining which color type is more prevalent
    mutate(
        More_Prevalent = 
            case_when(
                Primary > Secondary ~ "Primary",
                Primary < Secondary ~ "Secondary",
                TRUE ~ "Equal"
            )
    ) 
```

:::
:::

::: {visibility="uncounted"}
## Pipe Example (8/8) {.noframenumbering style="font-size: .8em"}

::: longer-code

```{r style="font-size: 1.1em;"}
#| message: false
#| warning: false
#| output-location: column
# Begin with mm.tidy
mm.tidy |>
    # Create new column: Primary_Color
    mutate(
        Color_Type = case_when(
            Color %in% c("Red", "Blue", "Yellow") ~ "Primary",
            TRUE ~ "Secondary"),    
        ) |> 
    # Group by color type & bag
    group_by(Color_Type, Bag) |>
    # Summarize total M&Ms per group
    summarize(Total_Number = sum(Number)) |>
    # Arrange by bag then color_type
    arrange(Bag, Color_Type) |> 
    # Pivot wider: one row per bag
    pivot_wider(
        names_from = Color_Type,
        values_from = Total_Number
    ) |> 
    # Add column determining which color type is more prevalent
    mutate(
        More_Prevalent = 
            case_when(
                Primary > Secondary ~ "Primary",
                Primary < Secondary ~ "Secondary",
                TRUE ~ "Equal"
            )
    ) |> 
    # Filter to only bags where primary and secondary are equal
    filter(More_Prevalent == "Equal")
    
```

:::
:::

# `tidyr`

Coming Thursday!
