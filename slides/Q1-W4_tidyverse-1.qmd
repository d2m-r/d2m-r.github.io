---
title: "Welcome to the Tidyverse"
subtitle: "ecosystem, read-in/-out, data manipulation"
date: "1/27/2026" # M/D/Y
footer: "D2M-R I | Week 4" #  quarter, week, and class

format: revealjs
engine: knitr

revealjs-plugins:
  - codefocus
  - fullscreen

fullscreen: false

execute:
  echo: true
  warning: false
  message: false
editor: source
---

```{r}
#| label: setup
#| include: false

library(tidyverse)
```

# Tidy Data

## What Makes Data "Tidy"? 

::: {.r-stack}

![](../images/tidyverse/tidy-data-def-frag1.jpg){.fragment height=700}

![](../images/tidyverse/tidy-data-def-frag2.jpg){.fragment height=700}

![](../images/tidyverse/tidy-data-def-frag3.jpg){.fragment height=700}

![](../images/tidyverse/tidy-data-def-frag4.jpg){.fragment height=700}

![](../images/tidyverse/tidy-data-def-frag5-FULL.jpg){.fragment height=700}
:::

<aside>Illustrations from the [Openscapes](https://www.openscapes.org/) blog [Tidy Data for reproducibility, efficiency, and collaboration](https://www.openscapes.org/blog/2020/10/12/tidy-data/) by Julia Lowndes and Allison Horst</aside>


---

![](../images/tidyverse/tolstoy.png){.absolute top="0" right="0" height="200"}

![](../images/tidyverse/tidy-data-quote-frag1.jpg){.fragment height="300"}


![](../images/tidyverse/tidy-data-quote-frag2.jpg){.fragment height="300"}

---

::: columns

::: {.column}

![](../images/tidyverse/tidy-data-workshop-frag1.jpg){.fragment height="800"}

:::
::: {.column}

![](../images/tidyverse/tidy-data-workshop-frag2.jpg){.fragment height="800"}
:::

:::

## Messy vs. Tidy: Example {data-background-image="../images/misc/mms.jpg" data-background-opacity=0.1}

::::: {.container-fluid style="margin-top: -150px;"}
:::: {.row style="margin-bottom: 50px;"}
::: col-6

:::
::: col-6
::: {.callout-important style="font-size: 1.2em;"}

## These tables hold exactly the same data!

What are the differences? What are the advantages of each?

:::
:::
::::




```{r}
#| message: false
#| warning: false
#| eval: true
#| echo: false
library(messy)
library(tidyverse)

# Generate a messy dataset
set.seed(123)

mm.raw <- read_tsv("../data/MM.tsv") |> 
    # Assign an ID number to each row in a column "Bag"
    mutate(Bag = row_number()) |> 
    relocate(last_col(), .before = 1)

mm.messy <- mm.raw |> 
    set_names("ID", "RED", "GREEN", "Blue", "Orannge", "Ylw.", "X", "WT.GRAM") |> 
    relocate(last_col(), .before = 4) |>
    relocate(X, .after = 2) |>
    add_whitespace(messiness = .9) |>
    duplicate_rows(.3) |>
    make_missing()

mm.tidy <- mm.raw |> 
    pivot_longer(
        cols = 2:7,
        names_to = "Color",
        values_to = "Number"
    ) |> 
    select(Bag, Color, Number, Bag_Weight = Weight)
    
```

:::: row

::: col-7

```{r}
#| echo: true
#| eval: true

mm.raw
```

:::
::: col-5

```{r}
#| echo: true
#| eval: true
mm.tidy
```
:::
::::
:::::

::: bubble-chain
  <p class="bubble-left fragment">That messy data looks pretty clean to me...</p>
  <p class="bubble-right fragment">It *is* clean! It's just not **tidy**.</p>
:::

# Terminology Detour

## Messy, Clean, Tidy

::::: container-fluid

:::: row

::: col-6

::: {.card .fragment .h-100 style="font-size: .8em"}

::: card-header
::: {.card-title style="color: #fff"}

Messy data:

:::
:::

::: {.card-body .lessgap}

```{r}
#| echo: true
#| eval: true
mm.raw
```

:::
:::

:::

::: col-6

::: {.card .card-alt1 .fragment .h-100 style="font-size: .8em"}

::: card-header
::: {.card-title style="color: #fff"}

Also messy data:

:::
:::

::: {.card-body .lessgap}

```{r}
#| echo: true
#| eval: true
mm.messy
```

:::
:::

:::

::::

:::::

::: notes

**messy ≠ bad** (except in the tidyverse context)

- Data wrangling starts with reading your data, then prepping it for visualization & analysis
- To use tidyverse packages, this prepping includes tidying messy data
- This can be shockingly complicated and time-consuming!

:::


## "Messy" is messy

**Messy** can either mean "not clean" or "not tidy"

- **Always bad:** unclean + untidy (= messy)
- **Sometimes good:** clean + untidy (= messy)
- **Usually good:** clean + tidy (= tidy)

::: bubble-chain
  <p class="bubble-left fragment">It would make more sense to call it "untidy."</p>
  <p class="bubble-right fragment">You are not wrong.</p>
:::

## Tidy Data: Iris

```{r}
#| include: false

iris_1 <- iris |> head(10)

iris_2 <- iris |> 
    pivot_longer(
        cols = c(Sepal.Length, Sepal.Width, Petal.Length, Petal.Width),
        names_to = c("Flower_Part", "Measurement_Type"),
        names_sep = "\\."
    ) |>
    head(10)
```

::::: container-fluid

:::: row

::: col-4

The `iris` dataset is a classic example of tidy data.

Which of these two versions of `iris` is tidy?

:::

::: {.col-8 style="margin-top: -4.5em; padding-bottom: 1em;"}

::: {.overlap-box .smaller}

::: box-title
In tidy data:
:::

::: box-content
::: nonincremental

<ol>
<li>Each variable is one column.</li>
<li>Each observation is one row.</li>
<li>Each measurement is one cell.</li>
<li class="fragment">**Each unit depends on the research question.**</li>
</ol>

:::
:::

:::

:::



::::

:::: row

::: col-7

```{r}
#| echo: true

iris_1
```


:::

::: col-5

```{r}
#| echo: true

iris_2
```


:::

::::

:::::


::: notes

Consider `iris`—each row is one flower with four morphological measurements (sepal length, sepal width, petal length, petal width). This is tidy for the question: **"What morphological features distinguish these species?"**

Could you pivot `iris` longer with columns for `flower_part` (sepal/petal) and `measurement_type` (length/width)? Yes. Would it be tidy? Also yes—but for a different question: **"What determines the size of flower parts in general?"**

**The key distinction:** Are your columns measuring different variables or different levels of the same variable?

- **Different variables** → Keep separate columns
- **Different levels** → Pivot longer

Tidiness isn't absolute. It's defined by your analytical question. The same dataset can be tidy in multiple forms depending on what you're studying.

:::

## Data Preparation Terms

::: {style="font-size: .9em"}

| Process | Start State | Goal | End State | Examples |
|-----|-----|-----|-----|-----------|
| **Data Cleaning:** <br> Error correction | [Raw data]{.fragment fragment-index="1"} | [Accuracy, consistency, legibility]{.fragment fragment-index="2"} | [Clean data, not yet specialized]{.fragment fragment-index="3"} | [Removing duplicate data<br>Correcting syntax errors<br>Fixing typos<br>Handling missing values<br>Change data types]{.fragment fragment-index="4"} |
| **Data Wrangling:**  <br> Data preparation | [Clean data]{.fragment fragment-index="5"} | [Usability for medium-scope purpose]{.fragment fragment-index="6"} | [Interpretable and specialized data, not yet analyzable]{.fragment fragment-index="7"} | [Preparing for narrow use cases<br>Grouping and summarizing<br>Transforming variables or values]{.fragment fragment-index="8"} |
| **Data Transformation:**  <br> Data restructuring | [Interpretable data]{.fragment fragment-index="9"} | [Usability for narrow-scope tasks]{.fragment fragment-index="10"} | [Analyzable and visualizable data]{.fragment fragment-index="11"} | [Reshaping long ↔ wide<br>Generating new data-based variables<br>Merging datasets<br>Eliminating unnecessary data]{.fragment fragment-index="12"} |

:::

::: bubble-chain
<p class="bubble-left fragment">You use them differently in the core project instructions!</p>
<p class="bubble-left fragment">Those are the same thing!</p>
<p class="bubble-left fragment">That's not what I learned!</p>
<p class="bubble-right fragment">**OK FINE. Yes. You're all correct.** You're also all incorrect. Honestly it doesn't really matter. Just mess with your data until they are usable. Call it what you want as long as it works.</p>
:::

# Tidyverse Packages

::: {.r-stretch style="display: grid; grid-template-columns: repeat(4, 1fr); grid-template-rows: minmax(0, 1fr) minmax(0, 1fr); gap: 0.8em; padding-bottom: 1em;"}

::: {.contained-box .accent1 .fragment style="display: flex; flex-direction: column; align-items: center;"}

::: {.box-icon style="margin-bottom: 0.1em;"}

![](../images/icons/tv-icons/tibble.png){style="max-height: 2em;"}
:::

::: {.box-title style="font-size: 0.9em; margin-bottom: 0.2em;"}

::: {style="margin-bottom: -.4em !important; margin-top: -.4em !important;"}

[tibble]{.pkg}

:::

:::

::: {.box-content style="text-align: center;"}

Reimagine the dataframe

:::

:::

::: {.contained-box .accent1 .fragment style="display: flex; flex-direction: column; align-items: center;"}


::: {.box-icon style="margin-bottom: 0.1em;"}

![](../images/icons/tv-icons/readr.png){style="max-height: 2em;"}

:::

::: {.box-title style="font-size: 0.9em; margin-bottom: 0.2em;"}

::: {style="margin-bottom: -.4em !important; margin-top: -.4em !important;"}

[readr]{.pkg}

:::

:::

::: {.box-content style="text-align: center;"}

import and export tabular data

:::

:::

::: {.contained-box .accent1 .fragment style="display: flex; flex-direction: column; align-items: center;"}

::: {.box-icon style="margin-bottom: 0.1em;"}

![](../images/icons/tv-icons/dplyr.png){style="max-height: 2em;"}

:::

::: {.box-title style="font-size: 0.9em; margin-bottom: 0.2em;"}

::: {style="margin-bottom: -.4em !important; margin-top: -.4em !important;"}

[dplyr]{.pkg}

:::

:::

::: {.box-content style="text-align: center;"}

a grammar of data manipulation

:::

:::

::: {.contained-box .accent1 .fragment style="display: flex; flex-direction: column; align-items: center;"}

::: {.box-icon style="margin-bottom: 0.1em;"}

![](../images/icons/tv-icons/tidyr.png){style="max-height: 2em;"}

:::

::: {.box-title style="font-size: 0.9em; margin-bottom: 0.2em;"}

::: {style="margin-bottom: -.4em !important; margin-top: -.4em !important;"}

[tidyr]{.pkg}

:::

:::

::: {.box-content style="text-align: center;"}

tidy your messy data

:::

:::

::: {.contained-box .fragment style="display: flex; flex-direction: column; align-items: center;"}

::: {.box-icon style="margin-bottom: 0.1em;"}

![](../images/icons/tv-icons/purrr.png){style="max-height: 2em;"}

:::

::: {.box-title style="font-size: 0.9em; margin-bottom: 0.2em;"}

::: {style="margin-bottom: -.4em !important; margin-top: -.4em !important;"}

[purrr]{.pkg}

:::

:::

::: {.box-content style="text-align: center;"}

enhance R's functional programming

:::

:::

::: {.contained-box .fragment style="display: flex; flex-direction: column; align-items: center;"}

::: {.box-icon style="margin-bottom: 0.1em;"}

![](../images/icons/tv-icons/stringr.png){style="max-height: 2em;"}

:::

::: {.box-title style="font-size: 0.9em; margin-bottom: 0.2em;"}

::: {style="margin-bottom: -.4em !important; margin-top: -.4em !important;"}

[stringr]{.pkg}

:::

:::

::: {.box-content style="text-align: center;"}

simplify working with strings

:::

:::

::: {.contained-box .fragment style="display: flex; flex-direction: column; align-items: center;"}

::: {.box-icon style="margin-bottom: 0.1em;"}

![](../images/icons/tv-icons/forcats.png){style="max-height: 2em;"}

:::

::: {.box-title style="font-size: 0.9em; margin-bottom: 0.2em;"}

::: {style="margin-bottom: -.4em !important; margin-top: -.4em !important;"}

[forcats]{.pkg}

:::

:::

::: {.box-content style="text-align: center;"}

simplify working with factors

:::

:::

::: {.contained-box .fragment style="display: flex; flex-direction: column; align-items: center;"}

::: {.box-icon style="margin-bottom: 0.1em;"}

![](../images/icons/tv-icons/ggplot2.png){style="max-height: 2em;"}

:::

::: {.box-title style="font-size: 0.9em; margin-bottom: 0.2em;"}

::: {style="margin-bottom: -.4em !important; margin-top: -.4em !important;"}

[ggplot2]{.pkg}

:::

:::

::: {.box-content style="text-align: center;"}

a grammar of graphics

:::

:::

:::


# `tibble`

## `tibble`: Better Data Frames {.left-sidebar-slide fullscreen=true style="font-size: .8;"}

![](../images/icons/tv-icons/tibble.png){.absolute top=".5em" left="1em" height="3em; z-index: 10;"})



::: sidebar-column
::: sidebar-title

[tibble]{.pkg}: <br>Better Data Frames

:::

::: {.sidebar-content style="font-size: .8em"}

-   Adaptation of base R's `data.frame` 
-   Tibbles are *also* data.frames 
    -   Check with `class()` or `str()`
-   Tidyverse functions work with tibbles
    -   usually add the `tibble` class automatically
-   Functionally equivalent

:::

:::

::: main-content

::: {.r-stack}

![](../images/screenshots/iris-tabular.png){.fragment style="position: absolute; width: 60%; top: 2em; left: 2em;"}

![](../images/screenshots/iris-dataframe.png){.fragment style="position: absolute; width: 60%; top: 50%; left: 50%; transform: translate(-50%, -50%);"}

![](../images/screenshots/iris-tibble.png){.fragment style="position: absolute; width: 60%; bottom: 2em; right: 2em;"}

:::

:::

::: notes

Adaptation of base R's data.frame structure that makes a lot of things easier
Tibbles are also data.frames (check the class() or str() functions)
Tidyverse package(s) work with tibbles, not base data.frames
Load the tidyverse library to use tibble-related functions

:::

## `tibble`: implicit `data`

![](../images/icons/tv-icons/tibble.png){.absolute top="-1.5em" right="0em" height="4em;"}

-   Most Tidyverse functions *take* and *return* tibbles
    -   Notably `dplyr`, `tidyr`, and `ggplot2`
    -   Tibble is the required first argument (i.e., `data`)
-   As standalone functions, these require an explicit tibble argument:
    -   1st arg: `function(my_tbl, arg1, arg2)`
    -   Anywhere: `function(arg1, arg2, data = my_tbl)`
-   In *pipelines* using (`%>%` or `|>`), the tibble is implicit (omitted)
    -   Tibble output from `function1()` pipes `|>` to tibble input for `function2()`
    -   `function1(data, arg1, arg2) %>% function2(arg1, arg2)`

::: {.callout-tip .large .fragment}

### More on pipes later

More on the pipe operator and pipelines later. For now, know that when these slides show non-executed examples as `function(arg1, arg2)` as shorthand for `function(data, arg1, arg2)`.

:::

::: notes

The first argument for most tidyverse functions is `data`, the `tbl` passed to the function.

When running a tidyverse function on its own, you must include the tibble explicitly as a required argument either unnamed in the first position (`function(my_tbl, arg1, arg2)`) or anywhere by name (`function(arg1, arg2, data = my_tbl)`).

However, tidyverse functions are often used in a *pipeline* where the tibble is passed from one function to the next using a pipe operator (`%>%` or `|>`). Since tidyverse functions both *take* and *return* a tibble, the pipe automatically passes the output of one function as the first argument (`data`) of the next function in the chain, letting you omit it.

More on the pipe later. For now, know that when these slides show non-executed examples as `function(arg1, arg2)` as shorthand for `function(data, arg1, arg2)`.

::: 

# `readr`

## `readr`: Read & Write Tibbles {.left-sidebar-slide fullscreen=true style="font-size: .8;"}

![](../images/icons/tv-icons/readr.png){.absolute top=".5em" left="1em" height="3em; z-index: 10;"})


::: sidebar-column
::: sidebar-title

[readr]{.pkg}: <br> Read & Write Tibbles

:::
::: {.sidebar-content style="font-size: .8em"}

-   Import/export tabular data as tibbles
-   Functions start with `read_*()` and `write_*()`
-   Handle common file types: CSV, TSV, delimited, fixed-width
-   Other packages for Excel, SPSS, Google Sheets, JSON, databases

:::
:::

::: main-content

![](../images/screenshots/readr-specify.png){style="position: absolute; width: 80%; top: 50%; left: 50%; transform: translate(-50%, -50%);"}

:::


## What & Where

![](../images/icons/tv-icons/readr.png){.absolute top="-1.5em" right="0em" height="4em;"}

::::: container-fluid

::: {.row .d-flex }

::: {.col-6 .d-flex }

::: {.overlap-box .h-100 .w-100 .d-flex .flex-column}

::: box-title

Determine import function:

:::

::: {.box-content .flex-grow-1}

-   File extension?
-   Field separators?
-   Column names?
-   Non-tabular content?
-   Multiple sheets?

:::
        
:::

:::

::: {.col-6 .d-flex }

::: {.overlap-box .accent1 .h-100 .w-100 .d-flex .flex-column}

::: box-title

Determine file path:

:::

::: {.box-content .flex-grow-1}

-   Located in your repo
-   Protected data
    -   Add to `.gitignore` or `localonly`
    -   Only call in your *local* R scripts
-   Shared data
    -   In git-managed directory
    -   Callable by any/all scripts
-   Use relative paths

:::
        
:::
:::

::::

:::::


## Relative relativity

::: {.card style="font-size: 1.1em; font-weight: bolder; text-align: center; border-width:8px; border-color: #c00; flex: 1 1 100%; background-color: #ffeaa9; margin-bottom: 1.5em;"}

::: {.card-body style="display: flex; align-items: center; justify-content: center; gap: .1em;"}

![](../images/icons/priority.png){style="max-height: 3em;"}

Quarto documents handle relative paths differently than R scripts. 

![](../images/icons/priority.png){style="max-height: 3em;"}

:::

:::

In scripts, relative paths are relative to *the working directory*, your repo or project's top-level. In Quarto docs, relative paths are relative to *the location of the Quarto file itself*.

If you work in a single `.qmd` in the top-level of your repo, these are equivalent. Read from: `repo_name/data/file.csv`
    
If your `.qmd` is in any subfolder, you'll need to adjust. To read the same file from a code chunk in `repo_name/quarto/document.qmd`, use: `../data/file.csv`

This is for *all* file operations, not just `readr` functions.


::: aside
[`readr` cheatsheet](https://github.com/rstudio/cheatsheets/blob/main/data-import.pdf)
:::


## Importing with `readr` {.left-sidebar-slide fullscreen=true style="font-size: .8;"}

![](../images/icons/tv-icons/readr.png){.absolute top="1em" right="1em" height="4em;"})

::: sidebar-column
::: sidebar-title
**Importing** with [readr]{.pkg}: `read_*()`
:::

::: sidebar-content

-   `read_*()` import tabular data as tibbles
-   Optional `col_types` & `col_names` arguments:
-   Assign to object to save imported data

:::

:::

::: {.main-content style="padding-right: 5em;"}


```{.r style="margin-bottom: .5em"}
# Common read functions

read_csv()    # Comma separated values
read_csv2()   # Semicolon separator (comma = decimal)
read_tsv()    # Tab separated values
read_delim()  # Any delimiter
read_fwf()    # Fixed width files
read_table()  # Whitespace separated
```


```{.r code-line-numbers="1|2-3|5-9|11-14"}

# Default behavior - guesses all data types
my_tbl <- read_*(file.csv, col_types = NULL)

# Specify columns with cols()
my_cols <- read_*(file.csv, col_types = cols(
  my_factor = col_factor(),
  your_string = col_character()
))

# String shortcut:
# needs character for each col in order
# Use "?" for columns to guess
my_shortcut <- read_*(file.csv, col_types = "fc")
```

:::

## Exporting with `readr` {.left-sidebar-slide fullscreen=true style="font-size: .8;"}

![](../images/icons/tv-icons/readr.png){.absolute top="1em" right="1em" height="4em;"})

::: sidebar-column
::: sidebar-title
**Exporting** with [readr]{.pkg}: `write_*()`
:::

::: sidebar-content

::: {.tightlist}

-   `read_*()` functions have matched `write_*()` counterparts
-   Save tibbles to tabular files
-   Write *intermediate datasets* after:
    -   De-identifying data
    -   Complex wrangling
    -   Dropping unneeded data
    -   Managing empty data
-   Run from script or console, no object assignment

:::

:::

:::

::: {.main-content style="padding-right: 5em;"}

```{.r style="margin-bottom: .5em"}
# Common write_*() functions

write_delim()
write_csv()
write_csv2()
write_excel_csv()
write_excel_csv2()
write_tsv()
```


```{.r code-line-numbers="1|2-4|6|8-11|12,13"}

# Start with messy data
messy_df <- read_xlsx("localpath/messy.xlsx", 
                     sheet="my sheet")

# Process in R: tidy, clean, transform...

# Export clean version
clean_df <- # ... your cleaning steps
write_csv(clean_df, "localpath/clean.csv")

# Later, read the clean version
clean_df <- read_csv("localpath/clean.csv")

```


:::

::: notes

Export tibbles to create intermediate datasets between initial import and final analysis
Easily produce de-identified datasets to share with others
Save computational time by skipping costly read-in and wrangling steps (e.g., big files, many files, complex transformations)
readr can also export tibbles to tabular files with similar syntax to how it imports

:::

## {fullscreen=true}

::: {.container-fluid style="position: absolute; width: 95vw; top: 50%; left: 50%; transform: translate(-50%, -50%);"}

::: {.row}

::: {.col-3 .fragment fragment-index="1"}

![](../images/screenshots/process-messy-file.png){style="max-width: 120% !important; margin-top: 0em" alt="Messy Data File"}


:::

::: {.col-1 .fragment fragment-index="2"}

::: {style="text-align: center; margin-top: 50%;"}
::: {style="font-size: 2em"}
{{< bi arrow-right-circle-fill>}}
:::
:::
:::

::: {.col-4 .smaller .fragment fragment-index="2"}

```{.r}
# Read in messy data
messy_df <- read_xlsx(
    "localpath/messy.xlsx",
    sheet="my sheet"
    )
```

:::

::: {.col-1 .fragment fragment-index="3"}

::: {style="text-align: center; margin-top: 50%;"}
::: {style="font-size: 2em"}
{{< bi arrow-right-circle-fill >}}
:::
:::

:::

::: {.col-3 .smaller .fragment fragment-index="3"}

![](../images/icons/cleaning.png){style="max-height: 3.5em;" alt="Clean"} ![](../images/icons/lasso.png){style="max-height: 3.5em;" alt="Wrangle"}



:::

:::



<!-- open down arrow row -->

::: row

::: {.col-11 style="text-align: right;" .fragment fragment-index="4"}

::: {style="font-size: 2em"}
{{< bi arrow-down-circle-fill >}}
:::

:::


::: col-1

[.]{style="font-size: 0em;"}

:::

:::

<!-- close down arrow row -->


<!-- open second row -->

::: row

<!-- open tidy data card column -->
::: {.col-3 .smaller  .fragment fragment-index="6"}

::: {.card}

::: card-header
::: {.card-title style="color: #fff; font-size: .8em"}

My tidy data file:

:::
:::

::: {.card-body .lessgap style="font-size: .8em" .nonincremental}

-   Data needed for future R scripts *and nothing else*
-   Minimal, tabular (.csv)
-   No protected data
-   Added variables from initial wrangling

:::
:::

:::

<!-- close tidy data card column -->

<!-- open circular paths column -->

::: col-6



<!-- open left path row -->

::: {.row .fragment fragment-index="5"}

::: {.col-2 .fragment fragment-index="6"}

::: {style="text-align: center; "}
::: {style="font-size: 2em"}
{{< bi arrow-left-circle-fill >}}
:::
:::

:::

::: {.col-8 .smaller}

```{.r}
# Write out clean version
write_csv(clean_df, 
          "localpath/clean.csv")
```

:::

::: {.col-2}

::: {style="text-align: center;"}
::: {style="font-size: 2em"}
{{< bi arrow-left-circle-fill >}}
:::

:::

:::

:::

<!-- close left path row -->

<!-- open right path row -->

::: {.row style="margin-top: 1em;" .fragment fragment-index="7"}

::: {.col-2}

::: {style="text-align: center;"}
::: {style="font-size: 2em"}
{{< bi arrow-right-circle-fill >}}
:::
:::

:::

::: {.col-8 .smaller}

```{.r}
# Read in clean version
clean_df <- read_csv(
    "localpath/clean.csv")
```

:::

::: {.col-2}

::: {style="text-align: center;"}
::: {style="font-size: 2em"}
{{< bi arrow-right-circle-fill >}}
:::
:::

:::

:::

<!-- close right path row -->

:::

<!-- close circular paths column -->

<!-- open clean_df column -->

::: {.col-3 .fragment fragment-index="4"}


::: {.card .card-accent1 style="padding:0px"}

::: card-header
::: {.card-title style="color: #fff; font-size: .6em"}

`clean_df`:

:::
:::

::: {.card-body .lessgap style="font-size: .8em" .nonincremental}

-   Clean & tidy tibble
-   Data needed for analysis *and nothing else*

:::
:::

:::


<!-- close clean_df column -->

:::

<!-- close second row column -->

:::

<!-- close container -->


## Bonus: `readxl` & `googlesheets4`

![](../images/icons/tv-icons/readxl.png){.absolute top="-1.5em" right="4em" height="4em;"}
![](../images/icons/tv-icons/googlesheets4.png){.absolute top="-1.5em" right="0em" height="4em;"}

::: {.callout-note .large}

### Complementary packages to `readr`

- Mimic readr's [read_*]{.func} functions
    -   [same cheatsheet](https://github.com/rstudio/cheatsheets/blob/main/data-import.pdf)
- Specification for converting "complex" documents into a `tbl`-compatible format
- *Not* tidyverse packages
    - Install and load them separately!

:::

::: fragment

```{.r}
# readxl for Excel files
library(readxl)
read_excel("data.xlsx")

# googlesheets4 for Google Sheets
library(googlesheets4)
read_sheet("spreadsheet_url")
```
:::

## Practice: Read & Write (1)

::::: container-fluid

:::: row

::: col-5

::: overlap-box

::: box-title

Read in M&M data:

:::

::: box-content

1. Pull the `student-hub` repo (or find files on GitHub)
2. Find the Excel spreadsheet: `data/MM data.xlsx`
3. Install and load the [readxl]{.pkg} library
4. Use the `read_excel()` function to assign the data to a tibble called `mmdata`
5. Examine your data in the console to see if it matches the image

:::
        
:::

:::

::: col-7

![](../images/screenshots/mmdata-goal.png)

:::

::::

:::::


::: bubble-chain
  <p class="bubble-left fragment">It doesn't!</p>
  <p class="bubble-right fragment">Oh no! Thank heavens you are smarter than a computer.</p>
:::



## Practice: Read & Write (2)

::::: container-fluid

:::: row

::: col-7

::: overlap-box

::: box-title

Fix, read, write:

:::

::: box-content

1. Open `MM data.xlsx` in Excel (or similar) and examine it with your human eyeballs
    -   What about this file creates problems when you read-in?
    -   How might you fix the issue here in the Excel document? 
2. Review the `?read_excel` documentation 
    -   What arguments can you pass to `read_excel()` to fix the issue on read-in?
3. Use `read_excel()` to assign the data to a tibble called `mmdata` that looks like the image
4. Use `write_csv()` to save `mmdata` to an intermediate dataset at the location `student-hub/data/mmdata.csv`
    -   Use an appropriate relative path!


:::
        
:::

:::

::: col-5

![](../images/screenshots/mmdata-goal.png)

:::

::::

:::::


::: bubble-chain
  <p class="bubble-left fragment">It says that folder doesn't exist! <br> *(and/or)* <br> It doesn't read/write/both where I want it to!
</p>
  <p class="bubble-right fragment">Remember relative relativity. Are you reading and writing from a script, Quarto doc, or the console?</p>
:::


::: notes

Open `MM data.xlsx` in Excel (or similar) and examine it with your human eyeballs
What about this file creates problems when you read-in?
How would you fix the issue here in the Excel document? (just think; don't do it!)
Review the ?read_excel documentation 
What arguments can you pass to read_excel() to fix the issue on read-in?
Use the read_excel() function to assign the data to a tibble called mmdata that looks like the image
Use write_csv() to save mmdata to an intermediate dataset: `in-class-materials/data/mmdata.csv`

:::


# `dplyr`


## `dplyr`: Data Transformation {.left-sidebar-slide fullscreen=true style="font-size: .8;"}

![](../images/icons/tv-icons/dplyr.png){.absolute top=".5em" left="1em" height="3em; z-index: 10;"})


::: sidebar-column
::: sidebar-title

[dplyr]{.pkg}: <br> Grammar of Data Manipulation

:::
::: sidebar-content

-   Core tidyverse package for data transformation
-   Works with tibbles (and data.frames)
-   First argument always `data` (the tibble to transform)

:::
:::

::: main-content

::: {.r-stretch style="display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: minmax(0, 1fr) minmax(0, 1fr); gap: 0.8em;"}

::: {.contained-box .fragment style="display: flex; flex-direction: column; align-items: center; padding: 0.4em 0.3em 0.2em 0.3em;"}

::: {.box-icon style="margin-bottom: 0.1em;"}

{{< bi check2-square>}}

:::

::: {.box-title style="font-size: 0.9em; margin-bottom: 0.2em;"}

::: {style="margin-bottom: -.4em !important; margin-top: -.4em !important;"}

[select]{.func}

:::

:::

::: {.box-content style="text-align: center;"}

subset & sort columns

:::

:::

::: {.contained-box .fragment style="display: flex; flex-direction: column; align-items: center; padding: 0.4em 0.3em 0.2em 0.3em;"}

::: {.box-icon style="margin-bottom: 0.1em;"}

{{< bi funnel>}}

:::

::: {.box-title style="font-size: 0.9em; margin-bottom: 0.2em;"}

::: {style="margin-bottom: -.4em !important; margin-top: -.4em !important;"}

[filter]{.func}

:::

:::

::: {.box-content style="text-align: center;"}

subset rows

:::

:::

::: {.contained-box .fragment style="display: flex; flex-direction: column; align-items: center; padding: 0.4em 0.3em 0.2em 0.3em;"}

::: {.box-icon style="margin-bottom: 0.1em;"}

{{< bi layer-backward>}}

:::

::: {.box-title style="font-size: 0.9em; margin-bottom: 0.2em;"}

::: {style="margin-bottom: -.4em !important; margin-top: -.4em !important;"}

[arrange]{.func}

:::

:::

::: {.box-content style="text-align: center; overflow: hidden; min-height: 0; font-size: 0.9em; line-height: .9;"}

sort rows

:::

:::

::: {.contained-box .fragment style="display: flex; flex-direction: column; align-items: center; padding: 0.4em 0.3em 0.2em 0.3em;"}

::: {.box-icon style="margin-bottom: 0.1em;"}

{{< bi node-plus-fill>}}

:::

::: {.box-title style="font-size: 0.9em; margin-bottom: 0.2em;"}

::: {style="margin-bottom: -.4em !important; margin-top: -.4em !important;"}

[mutate]{.func}

:::

:::

::: {.box-content style="text-align: center;"}

create and modify columns

:::

:::

::: {.contained-box .fragment style="display: flex; flex-direction: column; align-items: center; padding: 0.4em 0.3em 0.2em 0.3em;"}

::: {.box-icon style="margin-bottom: 0.1em;"}

{{< bi calculator>}}

:::

::: {.box-title style="font-size: 0.9em; margin-bottom: 0.2em;"}

::: {style="margin-bottom: -.4em !important; margin-top: -.4em !important;"}

[summarize]{.func}

:::

:::

::: {.box-content style="text-align: center;"}

compute with multiple rows

:::

:::

::: {.contained-box .fragment style="display: flex; flex-direction: column; align-items: center; padding: 0.4em 0.3em 0.2em 0.3em;"}

::: {.box-icon style="margin-bottom: 0.1em;"}

{{< bi collection>}}

:::

::: {.box-title style="font-size: 0.9em; margin-bottom: 0.2em;"}

::: {style="margin-bottom: -.4em !important; margin-top: -.4em !important;"}

[group_by]{.func}

:::

:::

::: {.box-content style="text-align: center;"}

perform operations on subgroups

:::

:::


:::

:::

```{r}
#| include: false
#| echo: false

mm.sample <- head(mm.raw, 5)
```


## `select`: Subset columns {style="font-size: .8em"}

![](../images/icons/tv-icons/dplyr.png){.absolute top="-1.5em" right="0em" height="4em;"}

::::: container-fluid

:::: row

::: col-6

::: {.overlap-box}

::: box-title

Include/exclude syntax:

:::

::: box-content

```{.r}
select(tbl, col1, col2, ...)
```

::: {.nonincremental .fragment fragment-index="1"}
-   Column names are objects, not strings
    -   `select(mm.sample, Bag, Red)`
    -   *not* `select(mm.sample, "Bag", "Red")`

:::

::: {.nonincremental .fragment fragment-index="2"}
-   Include (default): 
    -   `select(col1, col2)`

:::

::: {.nonincremental .fragment fragment-index="3"}
-   Exclude with `-`:
    -   `select(-col3, -col4)`
    -   `select(-c(col3, col4))`
    
:::

::: {.nonincremental .fragment fragment-index="4"}
-   Use ranges:
    -   Name: `select(colA:colC)`
    -   Position: `select(1:3)`
    -   Exclude: `select(-(4:6))`

:::
        
:::

:::

:::

::: {.col-6 style="margin-top: 1em"}

::: {.fragment fragment-index="5"}
```{.r}
# Include specific columns 
select(mm.sample, Bag, Red, Green, Blue)

# Exclude specific columns
select(mm.sample, -Orange, -Yellow, -Brown, -Weight)

# Exclude list of columns
select(mm.sample, -c(Orange, Yellow, Brown, Weight))

# Include columns by name range
select(mm.sample, Bag:Blue)

# Exclude columns by position range
## `-` requires range in `()`
select(mm.sample, -(5:8))
```
:::

::: {.fragment fragment-index="6" style="margin-top: 1em;"}
```{r}
#| echo: false
select(mm.sample, Bag, Red, Green, Blue)
```
:::

:::

::::

:::::








## `select`: Rename & reorder columns {style="font-size: .8em"}

![](../images/icons/tv-icons/dplyr.png){.absolute top="-1.5em" right="0em" height="4em;"}

::::: container-fluid

:::: row

::: col-4

::: overlap-box

::: box-title

Rename & order:

:::

::: box-content

::: {.nonincremental .fragment fragment-index="1"}
-   Select & reorder:
    -   `select(col3, col1, col2)`
:::

::: {.nonincremental .fragment fragment-index="2"}
-   Select & rename:
    -   `select(new_name = old_name)`
:::

::: {.nonincremental .fragment fragment-index="3"}
-   Backticks for special characters:
    -   ``select(`col 2 (two)` = col2)``
:::

::: {.nonincremental .fragment fragment-index="4"}
-   Related function: [rename()](https://dplyr.tidyverse.org/reference/rename.html){.func}
    -   Rename some or all columns
    -   Retain *all* columns *in original order*
:::

::: {.nonincremental .fragment fragment-index="5"}
-   Related function: [relocate()](https://dplyr.tidyverse.org/reference/relocate.html){.func}
    -   Move columns to relative positions
    -   `relocate(col3, .before = col1)`
    -   Retain *all* columns *in original order*
:::
        
:::

:::

:::

::: col-3

::: {.fragment style="margin-top: .2em;" fragment-index="1"}
```{r}
# Select and reorder
select(mm.sample, 
       Green, Blue, Bag, Red)
```
:::

::: {.fragment style="margin-top: .2em;" fragment-index="2"}
```{r}
# Select and rename
select(mm.sample, 
       Bag, rojo = Red, 
       vert = Green, 
       `aoi 青` = Blue)
```
:::

:::

::: col-5

::: {.fragment style="margin-top: .2em;" fragment-index="3"}
```{r}
# Select, reorder, rename
select(mm.sample, 
       vert = Green, 
       rojo = Red, 
       `aoi 青` = Blue, 
       Bag)
```
:::

::: {.fragment style="margin-top: .2em;" fragment-index="4"}
```{r}
# Rename w/out select or reorder
rename(mm.sample, 
       vert = Green, 
       rojo = Red, 
       `aoi 青` = Blue)
```
:::

:::

::::

:::::



## `select` Helpers

![](../images/icons/tv-icons/dplyr.png){.absolute top="-1.5em" right="0em" height="4em;"}

::::: container-fluid

:::: row

::: col-4

::: overlap-box

::: box-title

[tidy-select](https://tidyselect.r-lib.org/reference/index.html){style="color: #F8FdFE"}

:::

::: box-content

::: {.nonincremental .fragment fragment-index="1"}
-  `starts_with("prefix")`
:::

::: {.nonincremental .fragment fragment-index="2"}
-  `ends_with("suffix")`
:::

::: {.nonincremental .fragment fragment-index="3"}
-  `contains("text")`
:::

::: {.nonincremental .fragment fragment-index="4"}
-  `matches("regex")`
:::

::: {.nonincremental .fragment fragment-index="5"}
-  `num_range("x", 1:5)`
:::

::: {.nonincremental .fragment fragment-index="6"}
-  `everything()`
:::
        
:::

:::

:::

::: {.col-4 style="margin-top: -2em"}

::: {.fragment style="margin-top: .2em;" fragment-index="1"}
```{r}
# Select by first character(s)
select(mm.sample, 
       starts_with("B"))
```
:::

::: {.fragment style="margin-top: .2em;" fragment-index="2"}
```{r}
# Select by last character(s)
select(mm.sample, 
       ends_with("n"))
```
:::

:::

::: {.col-4 style="margin-top: -2em"}

::: {.fragment style="margin-top: .2em;" fragment-index="3"}
```{r}
# Select with regex
select(mm.sample, 
       contains("ow"))
```
:::

::: {.fragment style="margin-top: .2em;" fragment-index="4"}
```{r}
# Select with regex
select(mm.sample, 
       matches("^B|n$"))
```
:::

:::

::::

:::::


::: notes

Operates on columns/variables (not observations/rows)
Returns a tibble with
only the given columns
in the order given
renamed if provided
Remove columns with the hyphen
Includes everything not explicitly mentioned
Rename as you select with new_name = old_name


:::


## `filter`: Subset rows

![](../images/icons/tv-icons/dplyr.png){.absolute top="-1.5em" right="0em" height="4em;"}

<!-- begin container -->
::::: container-fluid

<!-- begin main row -->
:::: row

<!-- begin left column -->
::: col-5

::: {.overlap-box .accent1}

::: box-title

Filter syntax & logic:

:::

::: box-content

```{.r}
filter(tbl, cond1, cond2, ...)
```


-   Operates on rows (observations)
-   Conditional evaluation:
    -   Comparison operators (e.g., `>`, `!=`, `==`)
    -   Logical operators (e.g., `&`, `|`, `!`)
    -   Boolean values (`TRUE`, `FALSE`)
-   Returns tibble with rows that meet *all* conditions


:::

:::

:::
<!-- End left column -->

<!-- Begin right column -->
::: {.col-7 style="margin-top: -3em; font-size: .8em;"}

```{r}
#| include: false
# Vehicle dataframe (1 column called `transport`)
vehicles <- data.frame(
    transport = c("walking", "bus", "bicycle", "car", "atv",
                   "motorcycle", "razor scooter", "the el", 
                   "jet ski", "sailboat", "tricycle", "chariot")
)
# Condition 1
condition1 <- c("bicycle")

# Condition 2
condition2 <- c("bicycle", "atv", "motorcycle", "razor scooter", "jet ski", "atv")

# Condition 3
condition3 <- c("boat")

# Condition 4
condition4 <- c("bus", "bicycle", "car", "motorcycle", "razor scooter", "jet ski")
```

```{r}
#| eval: false
#| echo: true
# Vehicle dataframe (1 column called `transport`)
vehicles <- data.frame(
    transport = c("walking", "bus", "bicycle", "car", "atv",
                   "motorcycle", "razor scooter", "the el", 
                   "jet ski", "sailboat", "tricycle", "chariot"))

# Condition 1
filter(vehicles, transport == "bicycle")

# Condition 2
filter(vehicles, 
       has.handlebars(transport) | transport == "boat")

# Condition 3
filter(vehicles, 
       has.handlebars(transport), transport == "boat")

# Condition 3
filter(vehicles, 
       (has.handlebars(transport) & n.wheels(transport) < 3) |
           (requires.gas(transport) & n.wheels(transport) > 3))
```

<!-- Begin conditional results row -->
::: row

::: {.col-3 .fragment}

Condition 1:

```{r}
#| echo: false
filter(vehicles, transport %in% condition1)
```

:::

::: {.col-3 .fragment}

Condition 2:

```{r}
#| echo: false
filter(vehicles, transport %in% condition2)
```

:::

::: {.col-3 .fragment}

Condition 3:

```{r}
#| echo: false
filter(vehicles, transport %in% condition2, transport == "boat")
```

:::

::: {.col-3 .fragment}

Condition 4:

```{r}
#| echo: false
filter(vehicles, transport %in% condition4)
```

:::

:::
<!-- End conditional results row -->

:::
<!-- End right column -->

::::
<!-- end main row -->

:::::
<!-- end container -->

::: notes

Operates on observations/rows (not columns!)
Conditions are logical evaluations using:
>, >=, <, <=, != (“not equal to”), and == (“equal to”)
If the condition evaluates to TRUE, it stays and is returned or passed to the next line of the pipe
If FALSE, it's filtered out

:::




## `filter`: Subset rows

![](../images/icons/tv-icons/dplyr.png){.absolute top="-1.5em" right="0em" height="4em;"}

<!-- begin container -->
::::: container-fluid

<!-- begin main row -->
:::: row

<!-- begin left column -->
::: col-5

::: {.overlap-box .accent1}

::: box-title

Filter example:

:::

::: {.box-content .nonincremental}
```{r style="font-size: .9em"}
#| eval: false
#| echo: true

# Condition 1
filter(mm.tidy, Bag_Weight > 50)

# Condition 2
filter(mm.tidy, 
       Color == "Red" | Number >= 15)

# Condition 3
filter(mm.tidy, 
       Color == "Red", Number >= 15)

# Condition 4
filter(mm.tidy, 
       (Color == "Blue" & Number >= 5) |
           (Bag_Weight > 50.5 | Bag_Weight < 47),
       Bag != 6)
```

:::

:::

:::
<!-- End left column -->

<!-- Begin right column -->
::: {.col-7 style="margin-top: -3em; font-size: .8em;"}

<!-- Begin conditional results row 1 -->
::: row

::: {.col-6 .fragment}

Condition 1:

```{r}
#| echo: false
# Condition 1
filter(mm.tidy, Bag_Weight > 50)
```

:::

::: {.col-6 .fragment}

Condition 2:

```{r}
#| echo: false
# Condition 2
filter(mm.tidy, 
       Color == "Red" | Number >= 15)
```

:::

:::
<!-- End conditional results row 1

<!-- Begin conditional results row 2 -->
::: row

::: {.col-6 .fragment}

Condition 3:

```{r}
#| echo: false
# Condition 3
filter(mm.tidy, 
       Color == "Red", Number >= 15)
```

:::

::: {.col-6 .fragment}

Condition 4:

```{r}
#| echo: false
# Condition 4
filter(mm.tidy, 
       (Color == "Blue" & Number >= 5) |
           (Bag_Weight > 50.5 | Bag_Weight < 47),
       Bag != 6)
```

:::

:::
<!-- End conditional results row 2 -->

:::
<!-- End right column -->

::::
<!-- end main row -->

:::::
<!-- end container -->

::: notes

Operates on observations/rows (not columns!)
Conditions are logical evaluations using:
>, >=, <, <=, !=, ==
If the condition evaluates to TRUE, it stays and is returned or passed to the next line of the pipe
If FALSE, it's filtered out

:::



## `arrange`: Sort rows

![](../images/icons/tv-icons/dplyr.png){.absolute top="-1.5em" right="0em" height="4em;"}

::::: container-fluid

:::: row

::: col-4

::: overlap-box

::: box-title

Arrange syntax:

:::

::: box-content

```{.r}
arrange(tbl, col1, col2, ...)
```

-   Sort rows by column values
-   If 2+ variables, sorts in order given
-   Strings sorted alphabetically
-   Ascending order (default)
-   Descending order:
    -   `arrange(desc(col1))`
    -   `arrange(-col1)`
        
:::

:::

:::

::: {.col-4 style="font-size: .8em;"}

::: {.fragment style="margin-top: 1em;"}
```{r}
# Sort by (ascending) bag weight
arrange(mm.tidy, Bag_Weight)
```
:::

:::

::: {.col-4 style="font-size: .8em;"}

::: {.fragment style="margin-top: 1em;"}
```{r}
# Sort by color -> desc number -> desc bag
arrange(mm.tidy, Color, -Number, desc(Bag))
```
:::

:::

::::

:::::

::: notes

Sort rows of your tibble in the order of col1, then col2, etc.
Defaults to ascending order, but you can wrap the column name in the desc() function to use descending order
The hyphen - is shorthand for desc()

:::

## `mutate`: Create & modify columns {style="font-size: .8em"}

![](../images/icons/tv-icons/dplyr.png){.absolute top="-1.5em" right="0em" height="4em;"}

::::: container-fluid

:::: row

::: col-3

::: {.overlap-box .accent1}

::: {.box-title style="font-size: .9em"}
Create & modify:
:::

::: box-content

```{.r}
mutate(tbl, 
    new_col1 = ..., 
    new_col2 = ..., 
    ...)
```

-   Add named new column
-   Assign values with `=`
-   Compute values by row
-   Columns created in order
    -   Reference a newly created column in subsequent columns
-   Modify an existing column by creating a new column with the same name

:::

:::

:::


::: {.col-4 style="font-size: .8em, margin-top: -2em"}

::: {.fragment style="margin-top: 1em;"}

```{r}
# Create new column: Weight_Oz
# then pipe to select cols
mutate(mm.sample,
    Type = "Chocolate") |> 
    select(Bag, Weight, Type) 
```

:::

::: {.fragment style="margin-top: 1em;"}

```{r}
# Create new column: Weight_Oz
mutate(mm.sample,
    Weight_Oz = Weight / 28.34952) |> 
    select(Bag, Weight, Weight_Oz)
```

:::

:::

::: {.col-5 style="margin-top: -4.5em"}

::: {.fragment style="margin-top: 1em;"}

```{r}
# Create new column (total M&Ms per bag)
# Then another new column (proportion of red M&Ms)
# using the first new column
mutate(mm.sample,
    Total_MMs = Red + Green + Blue + 
        Brown + Yellow + Orange,
        Prop_Red = Red / Total_MMs) |> 
    select(Bag, Red, Total_MMs, Prop_Red)
```

:::

::: {.fragment style="margin-top: 1em;"}

```{r}
# Change values in existing column by overwriting
mutate(mm.sample,
        Weight = case_when(
        Weight < 48 ~ "Light",
        Weight > 50 ~ "Heavy",
        TRUE ~ "Medium" # anything left after
        )) |> 
select(Bag, Red, Weight)
```

:::

:::

::::

:::::

::: notes

Adds new column(s) with names and values that you define
Use the single equals sign to assign new values
Use double equal signs to mean "equals" within a conditional statement
*Use mutate to effectively change data in an existing variable by creating a new variable with the same name that will overwrite it


:::


## `summarize` & `group_by`: Compute summary values {style="font-size: .8em"}

![](../images/icons/tv-icons/dplyr.png){.absolute top="-1.5em" right="0em" height="4em;"}

::::: container-fluid

:::: row

::: col-4

::: {.overlap-box}

::: box-title
Group & summarize:
:::

::: box-content

```{.r}
group_by(tbl, col1, col2, ...)  |> 
summarize(
    summary_col1 = summary_func(colA),
    summary_col2 = summary_func(colB),
...)
```

-   `group_by()` creates subgroups based on unique values across 1+ columns
    -   Tidy `group`ing needs tidy data
-   `summarize()` computes summary functions across those groups
    -   e.g., `mean()`, `max()`, `last()`, `n()`
-   Output tibble includes:
    -   Grouping column(s)
    -   New summary column(s)


:::

:::

:::

::: col-4

```{r}
#| output-location: fragment
# Compute mean weight of all bags
summarize(mm.tidy, 
          Mean_Weight = mean(Bag_Weight))
```

```{r style="margin-top: .1em"}
#| output-location: fragment
# Group by color
group_by(mm.tidy, Color) |>  
# pipe grouped data to next function
# Compute total count and mean weight *per color*
summarize(Mean_Weight = mean(Bag_Weight),
          Total_Number = sum(Number))
```

:::

::: col-4
```{r}
#| include: false
# Grouping by multiple columns creates a summary value for each 
# unique combination of values in those columns
mm.tidy.weights <- mm.tidy |> 
    mutate(Weight_Class = case_when(
        Bag_Weight < 48 ~ "Light",
        Bag_Weight > 50 ~ "Heavy",
        TRUE ~ "Medium"
    ))
```

```{r}
#| output-location: fragment
# `mm.tidy.weights` includes a Weight_Class column
# Grouping by multiple columns creates a summary value for each 
# unique combination of values in those columns
group_by(mm.tidy.weights, Color, Weight_Class) |> 
summarize(Mean_Weight = mean(Bag_Weight),
          Total_Number = sum(Number))
```

:::

::::

:::::

::: notes

summarize() will compute a summary function (e.g., mean, maximum, last) across a variable
grouping your data first lets you summarize based on subsets within 1 or more columns
group_by() a categorical variable then pipe it into a summarize()
the resulting tibble will ONLY have the columns you created in the summarize()

In the example with both mean weight and total number of M&Ms, both summary values are computed for each color subgroup. Mean weight is identical for all colors; total number is not. Figure out why.

::: 


# `magrittr` & pipes

![](../images/comics-memes/une-pipe.png)

---

## The Pipe Operator(s)

![](../images/icons/tv-icons/dplyr.png){.absolute top="-1.5em" right="4em" height="4em;"}
![](../images/icons/tv-icons/magrittr.png){.absolute top="-1.5em" right="0em" height="4em;"}

[Pipes]{.keyword} create [pipelines]{.keyword}, human-readable alternative to multiple embedded functions.

::::: container-fluid
:::: row
::: fragment
```{.r}
as much as you like(change it with function Y(change it with function X(create some data)))
```
:::
::::

:::: {.row style="margin-top: 1em;"}

::: {.col-6 .fragment}

```{.r}
create some data |> 
    change it with function X |> 
    change it with function Y |> 
    as much as you like
```

:::

::: {.col-6 .fragment}

```{.r}
mm.tidy |> 
    group_by(Color) |> 
    summarize(Mean_Number = mean(Number)) |> 
    filter(Mean_Number < 10)
```

:::

::::

:::: row

::: {.callout-note .fragment}

### `|>` vs. `%>%`

[base]{.pkg} R has a native `|>` pipe. [magrittr]{.pkg} adds the `%>%` pipe for tidyverse use.

The `%>%` pipe was the standard for many years in the tidyverse. It is usable, maintained, and popular, but no longer necessary. 

As of R 1.4.0, `|>` is the [recommend pipe](https://r4ds.hadley.nz/data-transform.html#sec-the-pipe) for most uses. Now that it plays nicely with tidyverse pipelines, you can consistently just use `|>` whether you're working in the tidyverse or not. Updated D2M-R materials will use the `|>` pipe going forward, but older materials may still use `%>%`.

**Either works.**

:::

::::
:::::


## Pipe Example (1/8) {style="font-size: .8em"}

::: longer-code

```{r style="font-size: 1.1em;"}
#| message: false
#| warning: false
#| output-location: column-fragment
# Begin with mm.tidy
mm.tidy
```

:::

::: {visibility="uncounted"}
## Pipe Example (2/8) {.noframenumbering style="font-size: .8em"}

::: longer-code

```{r style="font-size: 1.1em;"}
#| message: false
#| warning: false
#| output-location: column-fragment
# Begin with mm.tidy
mm.tidy |>
    # Create new column: Primary_Color
    mutate(
        Color_Type = case_when(
            Color %in% c("Red", "Blue", "Yellow") ~ "Primary",
            TRUE ~ "Secondary"),    
        )
```

:::
:::


::: {visibility="uncounted"}
## Pipe Example (3/8) {.noframenumbering style="font-size: .8em"}

::: longer-code

```{r style="font-size: 1.1em;"}
#| message: false
#| warning: false
#| output-location: column-fragment
# Begin with mm.tidy
mm.tidy |>
    # Create new column: Primary_Color
    mutate(
        Color_Type = case_when(
            Color %in% c("Red", "Blue", "Yellow") ~ "Primary",
            TRUE ~ "Secondary"),    
        ) |> 
    # Group by color type & bag
    group_by(Color_Type, Bag)
```

:::
:::

::: {visibility="uncounted"}
## Pipe Example (4/8) {.noframenumbering style="font-size: .8em"}

::: longer-code

```{r style="font-size: 1.1em;"}
#| message: false
#| warning: false
#| output-location: column-fragment
# Begin with mm.tidy
mm.tidy |>
    # Create new column: Primary_Color
    mutate(
        Color_Type = case_when(
            Color %in% c("Red", "Blue", "Yellow") ~ "Primary",
            TRUE ~ "Secondary"),    
        ) |> 
    # Group by color type & bag
    group_by(Color_Type, Bag) |>
    # Summarize total M&Ms per group
    summarize(Total_Number = sum(Number))
```

:::
:::

::: {visibility="uncounted"}
## Pipe Example (5/8) {.noframenumbering style="font-size: .8em"}

::: longer-code

```{r style="font-size: 1.1em;"}
#| message: false
#| warning: false
#| output-location: column-fragment
# Begin with mm.tidy
mm.tidy |>
    # Create new column: Primary_Color
    mutate(
        Color_Type = case_when(
            Color %in% c("Red", "Blue", "Yellow") ~ "Primary",
            TRUE ~ "Secondary"),    
        ) |> 
    # Group by color type & bag
    group_by(Color_Type, Bag) |>
    # Summarize total M&Ms per group
    summarize(Total_Number = sum(Number)) |>
    # Arrange by bag then color_type
    arrange(Bag, Color_Type)
```

:::
:::

::: {visibility="uncounted"}
## Pipe Example (6/8) {.noframenumbering style="font-size: .8em"}

::: longer-code

```{r style="font-size: 1.1em;"}
#| message: false
#| warning: false
#| output-location: column-fragment
# Begin with mm.tidy
mm.tidy |>
    # Create new column: Primary_Color
    mutate(
        Color_Type = case_when(
            Color %in% c("Red", "Blue", "Yellow") ~ "Primary",
            TRUE ~ "Secondary"),    
        ) |> 
    # Group by color type & bag
    group_by(Color_Type, Bag) |>
    # Summarize total M&Ms per group
    summarize(Total_Number = sum(Number)) |>
    # Arrange by bag then color_type
    arrange(Bag, Color_Type) |> 
    # Pivot wider: one row per bag
    pivot_wider(
        names_from = Color_Type,
        values_from = Total_Number
    )
```

:::

::: notes

We haven't talked about pivot wider yet but it's coming up next!

:::

:::

::: {visibility="uncounted"}
## Pipe Example (7/8) {.noframenumbering style="font-size: .8em"}

::: longer-code

```{r style="font-size: 1.1em;"}
#| message: false
#| warning: false
#| output-location: column-fragment
# Begin with mm.tidy
mm.tidy |>
    # Create new column: Primary_Color
    mutate(
        Color_Type = case_when(
            Color %in% c("Red", "Blue", "Yellow") ~ "Primary",
            TRUE ~ "Secondary"),    
        ) |> 
    # Group by color type & bag
    group_by(Color_Type, Bag) |>
    # Summarize total M&Ms per group
    summarize(Total_Number = sum(Number)) |>
    # Arrange by bag then color_type
    arrange(Bag, Color_Type) |> 
    # Pivot wider: one row per bag
    pivot_wider(
        names_from = Color_Type,
        values_from = Total_Number
    ) |> 
    # Add column determining which color type is more prevalent
    mutate(
        More_Prevalent = 
            case_when(
                Primary > Secondary ~ "Primary",
                Primary < Secondary ~ "Secondary",
                TRUE ~ "Equal"
            )
    ) 
```

:::
:::

::: {visibility="uncounted"}
## Pipe Example (8/8) {.noframenumbering style="font-size: .8em"}

::: longer-code

```{r style="font-size: 1.1em;"}
#| message: false
#| warning: false
#| output-location: column-fragment
# Begin with mm.tidy
mm.tidy |>
    # Create new column: Primary_Color
    mutate(
        Color_Type = case_when(
            Color %in% c("Red", "Blue", "Yellow") ~ "Primary",
            TRUE ~ "Secondary"),    
        ) |> 
    # Group by color type & bag
    group_by(Color_Type, Bag) |>
    # Summarize total M&Ms per group
    summarize(Total_Number = sum(Number)) |>
    # Arrange by bag then color_type
    arrange(Bag, Color_Type) |> 
    # Pivot wider: one row per bag
    pivot_wider(
        names_from = Color_Type,
        values_from = Total_Number
    ) |> 
    # Add column determining which color type is more prevalent
    mutate(
        More_Prevalent = 
            case_when(
                Primary > Secondary ~ "Primary",
                Primary < Secondary ~ "Secondary",
                TRUE ~ "Equal"
            )
    ) |> 
    # Filter to only bags where primary and secondary are equal
    filter(More_Prevalent == "Equal")
    
```

:::
:::

# Combining datasets

*Bridging `base`, `dplyr` and `tidyr`*

::: notes

This is stuff from `dplyr` (and some analogs in base R), but conceptually it's related to reshaping data with `tidyr`.

:::

## Bind and join datasets

Two major categories of dataset combination: [*binding*]{.keyword} & [*joining*]{.keyword}.


::::: container-fluid

:::: {.row .equal-height style="height: 50vh;"}

::: col-6

::: {.callout-note .large icon=false style="font-size: 1.1em;" .fragment}

### [⬅︎ Append with `bind`]{style="padding-left:1em;"}

-   "Stack" datasets horizontally or vertically
-   Assumes similarly structured data frames (or tibbles)
-   Options from both [base]{.pkg} R and [dplyr]{.pkg}

:::

:::

::: col-6

::: {.callout-tip .large icon=false style="font-size: 1.1em;" .fragment}

### [➡ Merge with `join`]{style="padding-left:1em;"}

-   Combine datasets based on common columns
-   Works with tibbles and data.frames of variable structure
-   Core functionality from [dplyr]{.pkg}

:::

:::

::::

:::::

---

## Example Tibbles

```{r}
#| include: false
tibble1 <- tibble(col1 = c(1, 2, 3, 4, 5),
                  col2 = c(6, 7, 8, 9, 10),
                  col3 = c(11, 12, 13, 14, 15))

tibble2 <- tibble(col1 = c(16, 17, 18, 19, 20),
                  col2 = c(21, 22, 23, 24, 25),
                  col3 = c(26, 27, 28, 29, 30))

# a third with an extra column
tibble3 <- tibble(col1 = c(16, 17, 18, 19, 20),
                  col2 = c(21, 22, 23, 24, 25),
                  col3 = c(26, 27, 28, 29, 30),
                  col4 = c(31, 32, 33, 34, 35))

# a fourth with different column names
tibble4 <- tibble(col_1 = c(16, 17, 18, 19, 20),
                  col_2 = c(21, 22, 23, 24, 25),
                  col_3 = c(26, 27, 28, 29, 30))

# a fifth with a different number of rows
tibble5 <- tibble(col1 = c(16, 17, 18, 19, 20, 21),
                  col2 = c(21, 22, 23, 24, 25, 26),
                  col3 = c(26, 27, 28, 29, 30, 31))
```

::: container-fluid

::: row
::: col-4
`tibble1`
```{r}
#| echo: false
tibble1
```
:::
::: col-4
`tibble2`
```{r}
#| echo: false
tibble2
```
:::
::: col-4
`tibble3`
```{r}
#| echo: false
tibble3
```
:::
:::

::: row
::: col-6
`tibble4`
```{r}
#| echo: false
tibble4
```
:::
::: col-6
`tibble5`
```{r}
#| echo: false
tibble5
```
:::
:::
:::

---

## Binding Rows {style="font-size: .8em"}

![](../images/icons/tv-icons/dplyr.png){.absolute top="1em" right="1em" height="4em;"}

::::: container-fluid

:::: row

::: {.col-12 .fragment}

Append **rows** of one dataframe after the last row of another.
:::
:::
:::: row

::: col-6

::: {.card .fragment .h-100}

::: card-header
::: {.card-title style="color: #fff"}

[rbind]{.func}

:::
:::

::: {.card-body .lessgap .nonincremental}

-   Base R function
-   dfs must have exactly the same columns in exactly the same order

```{r}
rbind(tibble1, tibble2)
```

```{.r}
#| include: false
rbind(tibble1, tibble3) # error: col4 in tibble3
```



:::
:::

:::


::: col-6

::: {.card .fragment .card-alt1 .h-100}

::: card-header
::: {.card-title style="color: #fff"}

[bind_rows()]{.func}

:::
:::

::: {.card-body .lessgap .nonincremental}

-   Can have different columns
-   Missing values -> `NA`

```{r}
bind_rows(tibble1, tibble3)
```


:::
:::

:::

::::

:::::


---

## Binding Columns {style="font-size: .8em"}

![](../images/icons/tv-icons/dplyr.png){.absolute top="1em" right="1em" height="4em;"}


::::: container-fluid

:::: row

::: {.col-12 .fragment}

Append **columns** of one dataframe after the last column of another.
:::
:::
:::: row

::: col-6

::: {.card .fragment .h-100}

::: card-header
::: {.card-title style="color: #fff"}

[cbind]{.func}

:::
:::

::: {.card-body .lessgap .nonincremental}

-   Base R function
-   dfs must have same number rows

```{r}
cbind(tibble1, tibble4)
```

```{.r}
#| include: false
cbind(tibble1, tibble5) 
# Error in data.frame(..., check.names = FALSE) :
# arguments imply differing number of rows
```



:::
:::

:::


::: col-6

::: {.card .fragment .card-alt1 .h-100}

::: card-header
::: {.card-title style="color: #fff"}

[bind_cols()]{.func}

:::
:::

::: {.card-body .lessgap .nonincremental}

-  `dplyr` function
-   dfs must have same number rows

```{r}
bind_cols(tibble1, tibble3)
```

```{.r}
#| include: false
bind_cols(tibble1, tibble5) 
# Error in `bind_cols()`:
# ! Can't recycle `..1` (size 5) to match `..2` (size 6).
```

:::
:::

:::

::::

:::::

::: bubble-chain
  <p class="bubble-left fragment">If they work the same, which one should I use?</p>
  <p class="bubble-right fragment">Neither! Use joins instead.</p>
:::


## Joins (SQL-style) {.left-sidebar-slide fullscreen=true style="font-size: .8;"}

::: sidebar-column
::: sidebar-title
Joins
:::

-   Similar to database joins (SQL)
-   2 tibbles of 2 structures
    -   different rows
    -   different columns
-   Match rows based on common column(s)
    -   1 col: values are unique IDs
    -   2+ cols: values form unique ID combos

:::

::: {.main-content style="display: flex; align-items: center; justify-content: center; height: 100%;"}

::: {.r-stretch style="display: grid; grid-template-columns: 1fr auto 1fr; gap: 0.8em; align-items: center;"}


::: fragment
![](../images/misc/joins/setup.png)

:::

::: {.fragment style="display: flex; align-items: center; justify-content: center;"}

{{< bi arrow-right-circle-fill font-size="2em" >}}

:::

::: fragment
![](../images/misc/joins/setup2.png)
:::
:::

:::


## `left_join`: Keep left-df rows {style="font-size: .8em"}

![](../images/icons/tv-icons/dplyr.png){.absolute top="-1.5em" right="0em" height="4em;"}

::::: {.container-fluid style="font-size: .9em;"}

:::: row

::: col-5

::: {.overlap-box}

::: box-title

Left Join

:::

::: box-content


```{.r}
left_join(
  x,
  y,
  by = join_by(col1, x_col2 == y_col2)
  ...
)
```

::: tightlist
-   Start with all rows in **left** df `x`
-   Look for matching rows in **right** df `y`
    -   Keep rows from right df `y` that match
    -   Drop unmatched rows from right df `y`
-   Combine columns from right df `y` into left df `x`
    -   Matched rows have values in new cols
    -   Unmatched rows have `NA` in new cols
-   Default: `by = NULL` -> uses all common column names
-   Specify common columns with `by = join_by()`
    -   If same name in both dfs, just use column name
    -   If different names, use `x_col == y_col` format
-   Additional arguments for handling suffixes, etc.

:::
:::

:::

:::

::: {.col-7 style="margin-top: -4em"}

::: row
::: col-12
![](../images/misc/joins/left.png){style="max-height: 10em"}
:::
:::

::: row
::: col-4
```{r}
band_members
```
:::

::: col-4
```{r}
band_instruments
```
:::

::: col-4
```{r}
band_instruments2
```
:::
:::

::: row
::: col-6
::: {style="margin-top: 1em;"}
```{r}
#| output-location: fragment
left_join(band_members, 
    band_instruments
    )
```
:::
:::

::: col-6
::: {style="margin-top: 1em;"}
```{r}
#| output-location: fragment
left_join(band_members, 
    band_instruments2, 
    by = join_by(name == artist))
```
:::
:::

:::

:::

::::

:::::




## `right_join`: Keep right-df rows {style="font-size: .8em"}

![](../images/icons/tv-icons/dplyr.png){.absolute top="-1.5em" right="0em" height="4em;"}

::::: {.container-fluid style="font-size: .9em;"}

:::: row

::: col-5

::: {.overlap-box}

::: box-title

Right Join

:::

::: box-content


```{.r}
right_join(
  x,
  y,
  by = join_by(col1, x_col2 == y_col2)
  ...
)
```

::: tightlist
-   Start with all rows in **right** df `y`
-   Look for matching rows in **left** df `x`
    -   Keep rows from left df `x` that match
    -   Drop unmatched rows from left df `x`
-   Combine columns from left df `x` into right df `y`
    -   Matched rows have values in new cols
    -   Unmatched rows have `NA` in new cols

:::

::: {.fragment}

**`right_join(x,y)` is identical to `left_join(y,x)`**

:::

:::

:::

:::

::: {.col-7 style="margin-top: -4em"}

::: row
::: col-12
![](../images/misc/joins/right.png){style="max-height: 10em"}
:::
:::

::: row
::: col-4
```{r}
band_members
```
:::

::: col-4
```{r}
band_instruments
```
:::

::: col-4
```{r}
band_instruments2
```
:::
:::

::: row
::: col-6
::: {style="margin-top: 1em;"}
```{r}
#| output-location: fragment
right_join(band_members, 
    band_instruments
    )
```
:::
:::

::: col-6
::: {style="margin-top: 1em;"}
```{r}
#| output-location: fragment
right_join(band_members, 
    band_instruments2, 
    by = join_by(name == artist))
```
:::
:::

:::

:::

::::

:::::


## `inner_join`: Keep only matched rows {style="font-size: .8em"}

![](../images/icons/tv-icons/dplyr.png){.absolute top="-1.5em" right="0em" height="4em;"}

::::: {.container-fluid style="font-size: .9em;"}

:::: row

::: col-5

::: {.overlap-box}

::: box-title

Inner Join

:::

::: box-content


```{.r}
inner_join(
  x,
  y,
  by = join_by(col1, x_col2 == y_col2)
  ...
)
```

::: tightlist
-   Start with all rows in left df `x`
-   Look for matching rows in right df `y`
    -   Keep rows from right df `y` that match
    -   Drop unmatched rows from right df `y`
-   Continue with the modified `y`
-   Look for matching rows in left df `x`
    -   Keep rows from left df `x` that match
    -   Drop unmatched rows from left df `x`
-   Combine columns from modified right df `y` into modified left df `x`
    -   Only matched rows exist
    -   Nothing is filled with `NA`

:::

::: {.fragment}

**Same as `left_join(x,y)` then `right_join(x,y)` (or vice versa)**

:::

:::

:::

:::

::: {.col-7 style="margin-top: -4em"}

::: row
::: col-12
![](../images/misc/joins/inner.png){style="max-height: 10em"}
:::
:::

::: row
::: col-4
```{r}
band_members
```
:::

::: col-4
```{r}
band_instruments
```
:::

::: col-4
```{r}
band_instruments2
```
:::
:::

::: row
::: col-6
::: {style="margin-top: 1em;"}
```{r}
#| output-location: fragment
inner_join(band_members, 
    band_instruments
    )
```
:::
:::

::: col-6
::: {style="margin-top: 1em;"}
```{r}
#| output-location: fragment
inner_join(band_members, 
    band_instruments2,
    by = join_by(name == artist))
```
:::
:::

:::

:::

::::

:::::


## `full_join`: Keep all rows {style="font-size: .8em"}

![](../images/icons/tv-icons/dplyr.png){.absolute top="-1.5em" right="0em" height="4em;"}

::::: {.container-fluid style="font-size: .9em;"}

:::: row

::: col-5

::: {.overlap-box}

::: box-title

Full Join

:::

::: box-content


```{.r}
full_join(
  x,
  y,
  by = join_by(col1, x_col2 == y_col2)
  ...
)
```

::: tightlist
-   Start with all rows in left df `x`
-   Look for matching rows in right df `y`
    -   *Keep all rows*
-   Combine columns from right df `y` into left df `x`
    -   Matched rows have values in new cols
    -   Unmatched rows have `NA` in new cols
-   Continue with the modified `y`
-   Look for matching rows in left df `x`
    -   *Keep all rows*
-   Combine columns from modified right df `y` into modified left df `x`
    -   *No rows dropped*
    -   Cols from both `x` and `y` may have `NA`s

:::
::: {.fragment}

**Critically: (1) rows are not duplicated and (2) no data is lost.**

:::

:::

:::

:::

::: {.col-7 style="margin-top: -4em"}

::: row
::: col-12
![](../images/misc/joins/left.png){style="max-height: 10em"}
:::
:::

::: row
::: col-4
```{r}
band_members
```
:::

::: col-4
```{r}
band_instruments
```
:::

::: col-4
```{r}
band_instruments2
```
:::
:::

::: row
::: col-6
::: {style="margin-top: 1em;"}
```{r}
#| output-location: fragment
left_join(band_members, 
    band_instruments
    )
```
:::
:::

::: col-6
::: {style="margin-top: 1em;"}
```{r}
#| output-location: fragment
left_join(band_members, 
    band_instruments2,
    by = join_by(name == artist))
```
:::
:::

:::

:::

::::

:::::



# `tidyr`

## Example data frame for `tidyr`

```{r}
#| echo: true
#| output-location: column
# Generate example data for some tidyr functions
glasses <- tibble(
    condition = c(1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2),
    participant = c(1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6),
    score = runif(12),
    notes = c("glasses_none", "glasses_none", "none_none", "none_none",
              "none_incomplete", "none_incomplete", "none_none", "none_none",
              "glasses_none", "glasses_none", "glasses_late", "glasses_late")
)
```

## `tidyr`: Tidy messy data {.left-sidebar-slide fullscreen=true style="font-size: .8;"}

![](../images/icons/tv-icons/tidyr.png){.absolute top=".5em" left="1em" height="3em; z-index: 10;"})


::: sidebar-column
::: sidebar-title

[tidyr]{.pkg}: <br> Tidy messy data

:::
::: sidebar-content

-   Core tidyverse package for data tidying
-   Functions to reshape, split, merge, nest, and handle missing data
-   Works seamlessly with `dplyr` and tidy pipelines

:::
:::

::: main-content

::: {.r-stretch style="display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: minmax(0, 1fr) minmax(0, 1fr); gap: 0.8em;"}

::: {.contained-box .fragment style="display: flex; flex-direction: column; align-items: center; padding: 0.4em 0.3em 0.2em 0.3em;"}

::: {.box-icon style="margin-bottom: 0.1em;"}

{{< bi check2-square>}}

:::

::: {.box-title style="font-size: 0.9em; margin-bottom: 0.2em;"}

::: {style="margin-bottom: -.4em !important; margin-top: -.4em !important;"}

[pivot_*]{.func}

:::

:::

::: {.box-content style="text-align: center;"}

Reshape wide and long data

:::

:::

::: {.contained-box .fragment style="display: flex; flex-direction: column; align-items: center; padding: 0.4em 0.3em 0.2em 0.3em;"}

::: {.box-icon style="margin-bottom: 0.1em;"}

{{< bi funnel>}}

:::

::: {.box-title style="font-size: 0.9em; margin-bottom: 0.2em;"}

::: {style="margin-bottom: -.4em !important; margin-top: -.4em !important;"}

[separate_\*_\*]{.func}

:::

:::

::: {.box-content style="text-align: center;"}

Split values into columns

:::

:::

::: {.contained-box .fragment style="display: flex; flex-direction: column; align-items: center; padding: 0.4em 0.3em 0.2em 0.3em;"}

::: {.box-icon style="margin-bottom: 0.1em;"}

{{< bi collection>}}

:::

::: {.box-title style="font-size: 0.9em; margin-bottom: 0.2em;"}

::: {style="margin-bottom: -.4em !important; margin-top: -.4em !important;"}

[unite]{.func}

:::

:::

::: {.box-content style="text-align: center;"}

Collapse values across columns

:::

:::

::: {.contained-box .fragment style="display: flex; flex-direction: column; align-items: center; padding: 0.4em 0.3em 0.2em 0.3em;"}

::: {.box-icon style="margin-bottom: 0.1em;"}

{{< bi layer-backward>}}

:::

::: {.box-title style="font-size: 0.9em; margin-bottom: 0.2em;"}

::: {style="margin-bottom: -.4em !important; margin-top: -.4em !important;"}

[expand]{.func}(+)

:::

:::

::: {.box-content style="text-align: center; overflow: hidden; min-height: 0; font-size: 0.9em; line-height: .9;"}

Create missing combinations of data

:::

:::

::: {.contained-box .fragment style="display: flex; flex-direction: column; align-items: center; padding: 0.4em 0.3em 0.2em 0.3em;"}

::: {.box-icon style="margin-bottom: 0.1em;"}

{{< bi node-plus-fill>}}

:::

::: {.box-title style="font-size: 0.9em; margin-bottom: 0.2em;"}

::: {style="margin-bottom: -.4em !important; margin-top: -.4em !important;"}

[drop_na]{.func}(+)

:::

:::

::: {.box-content style="text-align: center;"}

Handle missing values

:::

:::

::: {.contained-box .fragment style="display: flex; flex-direction: column; align-items: center; padding: 0.4em 0.3em 0.2em 0.3em;"}

::: {.box-icon style="margin-bottom: 0.1em;"}

{{< bi calculator>}}

:::

::: {.box-title style="font-size: 0.9em; margin-bottom: 0.2em;"}

::: {style="margin-bottom: -.4em !important; margin-top: -.4em !important;"}

[nest]{.func}

:::

:::

::: {.box-content style="text-align: center;"}

Embed tables in tables

:::

:::



:::

:::

## Wide vs. Long Data


::::: container-fluid

:::: row

::: col-6

::: {.card .fragment .h-100}

::: card-header
::: {.card-title style="color: #fff"}

W--I--D--E Data

:::
:::

::: {.card-body .lessgap}

-   What Excel wants
-   First column (usually) contains unique values
-   Compact and human-friendly
-   Lacks precision
-   Difficult to manipulate structurally
-   Create with pivot_wider()

:::
:::

:::


::: col-6

::: {.card .fragment .card-alt1 .h-100}

::: card-header
::: {.card-title style="color: #fff"}

L*oooooo*ng Data

:::
:::

::: {.card-body .lessgap}

-   What the Tidyverse wants
-   First column (often) repeats values
-   Difficult to spot patterns or comparisons
-   Precise & standardized
-   Easily manipulable 
-   Create with pivot_longer()

:::
:::

:::

::::

:::::

::: notes

WIDE

What you're used to; "the Excel way"
First column contains unique values
Compact and human-friendly
Lacks precision, hard to manipulate structurally
create with pivot_wider()
formerly/alternatively: spread, cast, pivot, unfold


LONG

What the tidyverse wants
First column repeats values
Difficulty to spot patterns or comparisons
Easily manipulable, precise, standardized
create with pivot_longer()
formerly/alternatively: gather, melt, unpivot, fold


:::


## `pivot_longer`: Reshape wide to long {style="font-size: .8em"}

![](../images/icons/tv-icons/tidyr.png){.absolute top="-1.5em" right="0em" height="4em;"}

::::: container-fluid

:::: row

::: col-5

::: {.overlap-box style="font-size: .9em"}

::: box-title

Reshape long:

:::

::: box-content

```{.r}
pivot_longer(
    data, 
    cols = c(...), 
    names_to = "new_col1", 
    values_to = "new_col2",
    ...)
```

::: {.nonincremental .fragment fragment-index="1"}

-   Move from grid of values to key-value pairs
-   Human friendly -> tidyverse friendly

:::

::: {.nonincremental .fragment fragment-index="2"}

-   `cols = c(...)`: Specify columns to pivot
    -   *Which columns contain the data to consolidate?*
    -   Accepts tidyselect helpers

:::

::: {.nonincremental .fragment fragment-index="3"}

-   `names_to` = name of new column for former column names
    -   *Turn the pivoted columns' __names to__ values in this new column.*
    -   Column names will become strings
    
:::

::: {.nonincremental .fragment fragment-index="4"}

-   `values_to` = name of new column for former values
    -   *Turn the pivoted columns' __values to__ values in this new column.*
    -   Values must be of the same type

:::
        
:::

:::

:::

::: {.col-7 style="margin-top: 1em"}

::: {.fragment fragment-index="5"}

```{r}
#| echo: false
#| include: true
mm.raw
```

:::

::: row

::: col-12

::: {.fragment fragment-index="6" style="margin-top: 1em;"}

::: longer-code

```{r}
#| echo: true
#| output-location: column-fragment
mm.long <- pivot_longer(
    mm.raw,
    # pivot columns between Red and Brown
    cols = Red:Brown, 
    # column names go to "Color"
	names_to = "Color", 
    # column values go to "Number"
	values_to = "Number") 

mm.long
```
:::
:::

:::

:::

:::

::::

:::::
## `pivot_wider`: Reshape wide to long {style="font-size: .8em"}

![](../images/icons/tv-icons/tidyr.png){.absolute top="-1.5em" right="0em" height="4em;"}

::::: container-fluid

:::: row

::: col-5

::: {.overlap-box style="font-size: .9em"}

::: box-title

Reshape wide:

:::

::: box-content

```{.r}
pivot_wider(
    data, 
    id_cols = c(...),
    names_from = "col1", 
    values_from = "col2",
    ...)
```

::: {.nonincremental .fragment fragment-index="1"}

-   Move from key-value pairs to grid of values
-   Tidyverse friendly -> human friendly

:::

::: {.nonincremental .fragment fragment-index="2"}

-   `id_cols = c(...)`: Specify columns to keep as identifiers
    -   *Which columns should remain as-is (not pivoted)?*
    -   Defaults to all non-pivoted columns

:::

::: {.nonincremental .fragment fragment-index="3"}

-   `names_from` = name of column to use for new column names
    -   *Create column __names from__ values in which column?*
    
:::

::: {.nonincremental .fragment fragment-index="4"}

-   `values_from` = name of column to use for new values
    -   *Fill new columns with __values from__ which column?*

:::
        
:::

:::

:::

::: {.col-7 style="margin-top: 1em"}

::: row

::: col-5

::: {.fragment fragment-index="5"}

```{r}
#| echo: false
#| include: true
mm.long
```

:::

:::

::: col-7

::: {.fragment fragment-index="6" }

::: longer-code

```{.r}
mm.wide <- pivot_wider(
    mm.long,
    # Every value in `Color` becomes a column
	names_from = "Color", 
    # Values from `Number` go to new columns
	values_from = "Number") |> 
# Move `Weight` column to end
relocate(Weight, .after = last_col())

mm.wide
```

:::

:::

:::

:::

::: row

::: col-12

::: {.fragment fragment-index="7" style="margin-top: 1em;"}

```{r}
#| echo: false
mm.wide <- pivot_wider(
        mm.long,
        # Every value in `Color` becomes a column
    	names_from = "Color", 
        # Values from `Number` go to respective new columns
    	values_from = "Number") |> 
    # Move `Weight` column to end
    relocate(Weight, .after = last_col())

mm.wide
```

:::
:::

:::

:::

:::

:::

## `separate_wider_delim`: Split column into multiple columns {style="font-size: .8em"}


![](../images/icons/tv-icons/tidyr.png){.absolute top="-1.5em" right="0em" height="4em;"}

::::: container-fluid

:::: row

::: col-5

::: {.overlap-box style="font-size: .9em"}

::: box-title

Split column values:

:::

::: box-content

```{.r}
separate_wider_delim(
    data, 
    cols = c("col1", ...), 
    delim = "delimiter character(s)", 
    names = c("new_col1", "new_col2", ...),
    ...)
```


-   Split values in column into multiple columns based on delimiter characters
-   Non-character values (e.g., numbers) are coerced to character
-   Specify new column names
-   `cols = c("col1", ...)`: Specify column(s) to separate
    -   *Which column(s) contain the data to split?*
-   `delim = "delimiter character(s)"`: Character(s) to split on
    -   e.g., `,` or `"_"`
-   `names = c("new_col1", "new_col2", ...)`: Names for new columns
-   Related: 
    -   [`separate_wider_regex()`]{.func}: split by regex match
    -   [`separate_wider_position()`]{.func}: split values by fixed widths
    -   [`separate_longer_delim()`]{.func}: split into multiple rows

:::

:::

:::

::: col-7
::: fragment
```{r}
#| echo: false
head(glasses,5)
```
:::

::: {.fragment style="margin-top: 1em;"}
```{r}
#| output-location: fragment
separate_wider_delim(
    glasses,
    cols = notes,
    delim = "_",
    names = c(
        "wears_glasses", "notes"
        )
) |> 
    head(5)
```
:::

```{r}
#| eval: false
#| include: false
# Coerce numeric to character
separate_wider_delim(
    mm.raw,
    cols = Weight,
    delim = ".",
    names = c("WT_integer", "WT_decimal")
) |> 
    select(Bag, Red, WT_integer, WT_decimal)
```

:::

::::

:::::

## `unite`: Collapse multiple columns into one {style="font-size: .8em"}

![](../images/icons/tv-icons/tidyr.png){.absolute top="-1.5em" right="0em" height="4em;"}

::::: container-fluid
:::: row
::: col-5
::: {.overlap-box style="font-size: .9em"}
::: box-title
Collapse columns:
:::
::: box-content
```{.r}
unite(
    data,
    col = "new_col",
    old_col1,
    old_col2,
    ... # more columns
    sep = "separator character(s)",
    ...)
```

-   Combine multiple columns into one column
-   Values are concatenated with specified separator
-   `col = "new_col"`: Name of new column
-   `sep = "separator character(s)"`: Character(s) to insert between values
    -   Default: `_`
    -   Use empty string `""` for no separator
-   Use `remove = FALSE` to keep original columns

:::
:::
:::

::: col-7

::: {.fragment}

```{r}
#| echo: false
#| include: true

head(glasses,5)
```

:::
::: {.fragment style="margin-top: 1em;"}
```{r}
#| output-location: column-fragment

separate_wider_delim(
    glasses,
    cols = notes,
    delim = "_",
    names = c(
        "wears_glasses", "notes"
        )
) |> 
unite(
    col = "conditionParticipant",
    condition, participant,
    sep = ";",
) |>
head(5)
```


:::

:::

::::
:::::


## Tools for handling incomplete and missing data

Create a simple example dataset with missing values:

```{r}
#| include: false
# Create example tibble: daily temperature readings with gaps
weather <- tibble(
  date = as.Date(c("2026-01-20", "2026-01-21", "2026-01-21", "2026-01-23", "2026-01-24")),
  station = c("North", "North", "South", "South", "North"),
  temp_max = c(NA, 32, 28, 30, NA),
  temp_min = c(18, 15, NA, 20, 17),
  notes = c("Clear", NA, "Windy", NA, "Cloudy")
)

weather
```



## `expand` & `complete`: Create missing combinations {style="font-size: .8em"}




![](../images/icons/tv-icons/tidyr.png){.absolute top="-1.5em" right="0em" height="4em;"}

::::: container-fluid
:::: row

::: col-5

::: {.overlap-box}
::: box-title
Create missing combinations:
:::

::: box-content

:::: row
::: col-6
```{.r}
expand(
    data,
    col1 = c(...),
    col2 = c(...),
    ...)
)
```
:::

::: col-6
```{.r}
complete(
    data,
    col1 = c(...),
    col2 = c(...),
    ...)
)
```
:::
::::

-   [expand]{.func}: Generate all possible combinations of values across specified columns
-   [complete]{.func}: Fill in missing rows in data with `NA` for missing combinations
    -   Actually a wrapper for `expand()`
-   Useful for:
    -   Identifying non-obvious missing data points
    -   Preparing data for analyses that require complete cases
    -   Ensuring consistent structure across datasets
:::

:::
:::

::: col-7
::: {.fragment}

```{r}
#| echo: false
#| include: true

head(weather)
```


:::

:::: row
::: col-5
::: {.fragment style="margin-top: 1em;"}

```{r}
#| output-location: fragment

expand(weather, 
    date, 
    station)
```
:::
:::

::: col-7
::: {.fragment style="margin-top: 1em;"}
```{r}
#| output-location: fragment

complete(weather, date, station)
```
:::
:::
::::

:::


::::
:::::

## `drop_na` & `replace_na`: Drop and replace missing values

![](../images/icons/tv-icons/tidyr.png){.absolute top="-1.5em" right="0em" height="4em;"}

::: overlap-box

::: box-title

Drop rows with missing values

:::

::: box-content

```{r}
#| output-location: column-fragment

# Missing any value in any column
drop_na(weather) 
```

```{r}
#| output-location: column-fragment

# Missing values in specific columns
drop_na(weather, temp_max, temp_min)
```

:::

:::

::: {.overlap-box .overlap-box-blue}

::: box-title

Replace all `NA` in columns with specific value

:::

::: box-content

```{r}
#| output-location: column-fragment
replace_na(weather, 
           list(temp_max = 999, 
                temp_min = -999))
```

:::

:::


## `fill`: Dependently replace missing values {style="font-size: .7em;"}

![](../images/icons/tv-icons/tidyr.png){.absolute top="-1.5em" right="0em" height="4em;"}



::::: container-fluid

:::: row

::: col-4

::: {.card .fragment .h-100}

::: card-header
::: {.card-title style="color: #fff"}

Fill `NA` with previous:

:::
:::

::: {.card-body .lessgap}

```{r}
#| output-location: fragment

fill(weather, temp_max, .direction = "down")
```


:::
:::

:::

::: col-4

::: {.card .fragment .card-alt1 .h-100}

::: card-header
::: {.card-title style="color: #fff"}

Fill `NA` with next:

:::
:::

::: {.card-body .lessgap}

```{r}
#| output-location: fragment

fill(weather, temp_max, .direction = "up")
```

:::
:::

:::

::: col-4

::: {.card .fragment .h-100}

::: card-header
::: {.card-title style="color: #fff"}

Fill previous, then next:

:::
:::

::: {.card-body .lessgap}

```{r}
#| output-location: fragment

fill(weather, temp_max, .direction = "downup")
```

:::
:::

:::

::::

:::::

## Nesting

![](../images/icons/tv-icons/tidyr.png){.absolute top="-1.5em" right="0em" height="4em;"}

[Nesting]{.keyword}: embedding a data frame within a data frame

[Rectangling]{.keyword}: the reverse process of un-nesting (e.g., making JSON into tidy tibbles)

These are beyond the scope of this class, but here's some fine print if you're interested:

::: {.callout-tip .fragment .nonincremental}

### Nested Data

-   nested df is one where 1+ columns is a list of data frames
-   conceptually related to grouping with `group_by()`: 
    -   1 row in input -> 1 group in output

Imagine a data frame with columns x, y, and z:
```{.r}
df %>% group_by(x) %>% summarize(mean = mean(y), sum = sum(z))
```

Each row in the summarized output processes data (here the mean of y and the sum of z) about multiple rows in the input, defined by the unique values of the group (here x).

```{.r}
df2 %>% nest(my_nested_var = c(y, z))
```

Each row in the nested output contains the data itself (unchanged) associated with those rows (the values in columns y and z) as defined by the unique values of everything that isn't nested (here x). Since the data is unchanged, the data in the new variable is itself a table (or tibble). The columns in the nested tibble are the columns you passed to it and the rows are all the original rows within each "group".

:::

::: {.alert .alert-warning .fragment .nonincremental style="position: absolute; width: 50%; top: 3em; right: 3em;, font-size: .8em"}

**You probably won't need this** so don't stress if that seems like gibberish. It's just a useful concept. 

For more info see [this tidyverse article on nesting](https://tidyr.tidyverse.org/articles/nest.html). 

Page 2 of the [tidyr cheatsheet](https://github.com/rstudio/cheatsheets/blob/main/tidyr.pdf) is dedicated to nesting concepts and functions.

:::




# Summary

## Tidyverse Workflow


## Process/flow with icons

::: {style="display: grid; grid-template-columns: 1fr 0.3fr 1fr 0.3fr 1fr 0.3fr 1fr; grid-template-rows: auto 3em auto; gap: 8px;"}

<!-- Row 1: Steps 1-4 -->

::: {.flow-box style="grid-column: 1; grid-row: 1; background-color: #800000;" .fragment}


1. Import data with `readr`

::: flow-icon-circle

{{< bi diamond-half >}}

:::

:::

::: {.flow-arrow style="grid-column: 2; grid-row: 1;" .fragment}

{{< bi arrow-right-circle-fill >}}

:::

::: {.flow-box style="grid-column: 3; grid-row: 1; background-color: #6e0e10;" .fragment}

2. Apply structure with `tibble`

::: flow-icon-circle

{{< bi diamond-half >}}

:::

:::

::: {.flow-arrow style="grid-column: 4; grid-row: 1;" .fragment}

{{< bi arrow-right-circle-fill >}}

:::

::: {.flow-box style="grid-column: 5; grid-row: 1; background-color: #5b1b21;" .fragment}

3. Tidy data with `tidyr`


::: flow-icon-circle

{{< bi diamond-half >}}

:::

:::

::: {.flow-arrow style="grid-column: 6; grid-row: 1;" .fragment}

{{< bi arrow-right-circle-fill >}}

:::

::: {.flow-box style="grid-column: 7; grid-row: 1; background-color: #492931;" .fragment}

4. Manipulate tibbles with `dplyr`

::: flow-icon-circle

{{< bi diamond-half >}}

:::

:::

<!-- Down arrow -->

::: {.flow-arrow style="grid-column: 7; grid-row: 2;" .fragment}

{{< bi arrow-down-circle-fill >}}

:::

<!-- Row 2: Steps 5-8 (in reverse order) -->

::: {.flow-box style="grid-column: 7; grid-row: 3; background-color: #373642;" .fragment}

5. Manipulate strings with `stringr`

::: flow-icon-circle

{{< bi diamond-half >}}

:::

:::

::: {.flow-arrow style="grid-column: 6; grid-row: 3;" .fragment}

{{< bi arrow-left-circle-fill >}}

:::

::: {.flow-box style="grid-column: 5; grid-row: 3; background-color: #254452;" .fragment}

6. Manipulate factors with `forcats`

::: flow-icon-circle

{{< bi diamond-half >}}

:::

:::

::: {.flow-arrow style="grid-column: 4; grid-row: 3;" .fragment}

{{< bi arrow-left-circle-fill >}}

:::

::: {.flow-box style="grid-column: 3; grid-row: 3; background-color: #125163;" .fragment}

7. Visualize with `ggplot2`

::: flow-icon-circle

{{< bi diamond-half >}}

:::

:::

::: {.flow-arrow style="grid-column: 2; grid-row: 3;" .fragment}

{{< bi arrow-left-circle-fill >}}

:::

::: {.flow-box style="grid-column: 1; grid-row: 3; background-color: #005f73;" .fragment}

8. Model with `broom` and `modelr`

::: flow-icon-circle

{{< bi diamond-half >}}

:::

:::

:::
